["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Object",["^ "],"~$confirm",["^ "]],"~:use-macros",["^ ","~$go-loop","~$cljs.core.async.macros","~$*source-map-data*","~$cljs.compiler","~$emit","^9"],"~:excludes",["~#set",[]],"~:name","~$klipse-clj.lang.clojure.guard","~:imports",null,"~:requires",["^ ","~$ana","~$cljs.analyzer","^B","^B","^9","^9","~$cljs.core.async","^C"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","~$timeout","^C","~$<!","^C","^8","^9","^:","^9"],"~:defs",["^ ","~$watchdog",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","~:line",45,"~:column",7,"~:end-line",45,"~:end-column",15,"~:arglists",["~#list",["~$quote",["^R",[[]]]]]],"^=","~$klipse-clj.lang.clojure.guard/watchdog","^L","src/klipse_clj/lang/clojure/guard.cljs","^P",15,"~:method-params",["^R",[[]]],"~:protocol-impl",null,"~:arglists-meta",["^R",[null,null]],"^N",1,"~:variadic?",false,"^M",45,"~:ret-tag","~$any","^O",45,"~:max-fixed-arity",0,"~:fn-var",true,"^Q",["^R",["^S",["^R",[[]]]]]],"~$guard",["^ ","^J",null,"^K",["^ ","^L","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^M",50,"^N",3,"^O",50,"^P",8,"~:export",true,"^Q",["^R",["^S",["^R",[["~$max-eval-duration"]]]]]],"^=","~$klipse-clj.lang.clojure.guard/guard","^L","src/klipse_clj/lang/clojure/guard.cljs","^P",8,"^U",["^R",[["^13"]]],"^V",null,"^12",true,"^W",["^R",[null,null]],"^N",1,"^X",false,"^M",49,"^Y",["^<",[null,"~$clj-nil"]],"^O",50,"^[",1,"^10",true,"^Q",["^R",["^S",["^R",[["^13"]]]]]],"~$tick",["^ ","^J",null,"^K",["^ ","^L","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^M",31,"^N",7,"^O",31,"^P",11,"^Q",["^R",["^S",["^R",[[]]]]]],"^=","~$klipse-clj.lang.clojure.guard/tick","^L","src/klipse_clj/lang/clojure/guard.cljs","^P",11,"^U",["^R",[[]]],"^V",null,"^W",["^R",[null,null]],"^N",1,"^X",false,"^M",31,"^O",31,"^[",0,"^10",true,"^Q",["^R",["^S",["^R",[[]]]]]],"~$runonce",["^ ","^J",null,"^K",["^ ","^L","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^M",24,"^N",7,"^O",24,"^P",14,"^Q",["^R",["^S",["^R",[["~$f"]]]]]],"^=","~$klipse-clj.lang.clojure.guard/runonce","^L","src/klipse_clj/lang/clojure/guard.cljs","^P",14,"^U",["^R",[["~$f"]]],"^V",null,"^W",["^R",[null,null]],"^N",1,"^X",false,"^M",24,"^Y","~$function","^O",24,"^[",1,"^10",true,"^Q",["^R",["^S",["^R",[["~$f"]]]]]],"~$run-watchdog*",["^ ","^J",null,"^K",["^ ","^L","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^M",34,"^N",7,"^O",34,"^P",20,"^Q",["^R",["^S",["^R",[[]]]]],"~:doc","reset the *watchdog-tick* to the current time once in a while"],"^=","~$klipse-clj.lang.clojure.guard/run-watchdog*","^L","src/klipse_clj/lang/clojure/guard.cljs","^P",20,"^U",["^R",[[]]],"^V",null,"^W",["^R",[null,null]],"^N",1,"^X",false,"^M",34,"^Y","^Z","^O",34,"^[",0,"^10",true,"^Q",["^R",["^S",["^R",[[]]]]],"^1<","reset the *watchdog-tick* to the current time once in a while"],"~$watchdog-period",["^ ","^K",["^ ","^L","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^M",22,"^N",3,"^O",22,"^P",18,"^1<","The number of msec for the watchdog period.\n            This value has to be much lower than min-max-eval-duration."],"^=","~$klipse-clj.lang.clojure.guard/watchdog-period","^L","src/klipse_clj/lang/clojure/guard.cljs","^P",18,"^N",1,"^M",20,"^O",22,"~:tag","~$number","^1<","The number of msec for the watchdog period.\n            This value has to be much lower than min-max-eval-duration."],"~$min-max-eval-duration",["^ ","^=","~$klipse-clj.lang.clojure.guard/min-max-eval-duration","^L","src/klipse_clj/lang/clojure/guard.cljs","^M",19,"^N",1,"^O",19,"^P",27,"^K",["^ ","^L","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^M",19,"^N",6,"^O",19,"^P",27],"^1@","^1A"],"~$run-watchdog-once",["^ ","^=","~$klipse-clj.lang.clojure.guard/run-watchdog-once","^L","src/klipse_clj/lang/clojure/guard.cljs","^M",43,"^N",1,"^O",43,"^P",23,"^K",["^ ","^L","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^M",43,"^N",6,"^O",43,"^P",23],"^1@","^1:"],"~$my-emits",["^ ","^J",null,"^K",["^ ","^L","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^M",57,"^N",7,"^O",57,"^P",15,"^Q",["^R",["^S",["^R",[["^13","~$&","~$xs"]]]]],"^1<","same as cljs.compiler/emits with insertion of a `guard()` call before if and recur (emitted as continue) statement.\n\n  Limitations:\n  1. It doesn't prevent infinite loop in imported code e.g. (reduce + (range)\n  ","~:top-fn",["^ ","^X",true,"~:fixed-arity",1,"^[",1,"^U",[["^R",["^13","^1G"]]],"^Q",["^R",[["^13","~$&","^1G"]]],"^W",["^R",[null]]]],"^=","~$klipse-clj.lang.clojure.guard/my-emits","^L","src/klipse_clj/lang/clojure/guard.cljs","^P",15,"^1H",["^ ","^X",true,"^1I",1,"^[",1,"^U",[["^R",["^13","^1G"]]],"^Q",["^R",[["^13","~$&","^1G"]]],"^W",["^R",[null]]],"^U",[["^R",["^13","^1G"]]],"^V",null,"^1I",1,"^W",["^R",[null]],"^N",1,"^X",true,"~:methods",[["^ ","^1I",1,"^X",true,"^1@","^15"]],"^M",57,"^Y","^Z","^O",57,"^[",1,"^10",true,"^Q",["^R",[["^13","~$&","^1G"]]],"^1<","same as cljs.compiler/emits with insertion of a `guard()` call before if and recur (emitted as continue) statement.\n\n  Limitations:\n  1. It doesn't prevent infinite loop in imported code e.g. (reduce + (range)\n  "],"~$*watchdog-tick*",["^ ","^K",["^ ","^L","/Users/viebel/prj/klipse-clj/src/klipse_clj/lang/clojure/guard.cljs","^M",17,"^N",3,"^O",17,"^P",18,"^1<","each time the watchdog has a chance to run, this var is set with the current time","~:dynamic",true],"^=","~$klipse-clj.lang.clojure.guard/*watchdog-tick*","^L","src/klipse_clj/lang/clojure/guard.cljs","^P",18,"^N",1,"^1M",true,"^M",15,"^O",17,"^1@","^1A","^1<","each time the watchdog has a chance to run, this var is set with the current time"]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","^7","^7","^C","^C"],"~:cljs.analyzer/constants",["^ ","~:seen",["^<",["~:else","~:recur","~:gen-col"]],"~:order",["^1T","^1S","^1U"]],"^1<","The basic idea is that the first time a klipse snippet's cljs is evaluated, we kick off a go-loop whose job is to wake up every 100ms and update *watchdog-tick* to say: this is the last time that i woke up!\n\n  And if (guard) gets run and notices that the watchdog hasn't been able to wake up within the last *max-eval-duration* milliseconds, it decides that we should kill the currently evaluating function, and does that by throwing an error.\n\n  and this doesn't kill go-loops created by users' snippet code, because those go-loops won't block the watchdog from running.\n  "]