["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Infinity",["^ "],"~$Error",["^ "],"~$Function",["^ "],"~$Object",["^ "]],"~:use-macros",["^ ","~$postwalk","~$clojure.walk","~$union","~$clojure.set","~$join","~$clojure.string","~$split-lines","^=","~$blank?","^="],"~:excludes",["~#set",[]],"~:name","~$gadjett.collections","~:imports",null,"~:requires",["^ ","^;","^;","^9","^9","^=","^=","~$zip","~$clojure.zip","^G","^G"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","^8","^9","^:","^;","^<","^=","^>","^=","^?","^="],"~:defs",["^ ","~$unflatten-keys",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","~:line",485,"~:column",7,"~:end-line",485,"~:end-column",21,"~:arglists",["~#list",["~$quote",["^T",[["~$m"]]]]],"~:doc","\n  Unflattend the keys of a map that has been `flatten-keys`ed.\n\n~~~klipse\n(unflatten-keys {[:a :b] 1, [:c :d] 2, [:c :e] 4, [:c :f :g] 8})\n~~~\n"],"^B","~$gadjett.collections/unflatten-keys","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",21,"~:method-params",["^T",[["~$m"]]],"~:protocol-impl",null,"~:arglists-meta",["^T",[null,null]],"^P",1,"~:variadic?",false,"^O",485,"~:ret-tag",["^A",[null,"~$any"]],"^Q",485,"~:max-fixed-arity",1,"~:fn-var",true,"^S",["^T",["^U",["^T",[["~$m"]]]]],"^V","\n  Unflattend the keys of a map that has been `flatten-keys`ed.\n\n~~~klipse\n(unflatten-keys {[:a :b] 1, [:c :d] 2, [:c :e] 4, [:c :f :g] 8})\n~~~\n"],"~$sequence->map",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",136,"^P",7,"^Q",136,"^R",20,"^S",["^T",["^U",["^T",[["~$s"]]]]],"^V","Converts a sequence into a map where the keys are the indexes of the elements in the sequence.\n\n  ~~~klipse\n  (sequence->map [10 20 30])\n  ~~~\n  "],"^B","~$gadjett.collections/sequence->map","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",20,"^X",["^T",[["~$s"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",136,"^10","~$clj","^Q",136,"^12",1,"^13",true,"^S",["^T",["^U",["^T",[["~$s"]]]]],"^V","Converts a sequence into a map where the keys are the indexes of the elements in the sequence.\n\n  ~~~klipse\n  (sequence->map [10 20 30])\n  ~~~\n  "],"~$=without-keys?",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",37,"^P",7,"^Q",37,"^R",21,"^S",["^T",["^U",["^T",[["~$obj-a","~$obj-b","~$keys-list"]]]]],"^V","Compare two maps exclusing some keys\n\n~~~klipse\n  (=without-keys? {:a 1 :b 2 :c 3} {:a 1 :b 5} #{:b :c})\n~~~\n  "],"^B","~$gadjett.collections/=without-keys?","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",21,"^X",["^T",[["^18","^19","^1:"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",37,"^10","^11","^Q",37,"^12",3,"^13",true,"^S",["^T",["^U",["^T",[["^18","^19","^1:"]]]]],"^V","Compare two maps exclusing some keys\n\n~~~klipse\n  (=without-keys? {:a 1 :b 2 :c 3} {:a 1 :b 5} #{:b :c})\n~~~\n  "],"~$dissoc-in",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",340,"^P",7,"^Q",340,"^R",16,"^S",["^T",["^U",["^T",[["~$m",["~$k","~$&","~$ks","~:as","~$keys"]]]]]],"^V","Dissociates an entry from a nested associative structure returning a new nested structure. `keys` is a sequence of keys. Any empty maps that result will not be present in the new structure. See [assoc-in](https://clojuredocs.org/clojure.core/assoc-in)\n\n~~~klipse\n  (dissoc-in {:a 1 :b 2} [:b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2 :B 3} :c 3} [:a :b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2} :c 3} [:a :b])\n~~~\n  "],"^B","~$gadjett.collections/dissoc-in","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",16,"^X",["^T",[["~$m","~$p__18960"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",340,"^10",["^A",[null,"^16","^11","~$clj-nil"]],"^Q",340,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["~$m",["~$k","~$&","^1=","^1>","^1?"]]]]]],"^V","Dissociates an entry from a nested associative structure returning a new nested structure. `keys` is a sequence of keys. Any empty maps that result will not be present in the new structure. See [assoc-in](https://clojuredocs.org/clojure.core/assoc-in)\n\n~~~klipse\n  (dissoc-in {:a 1 :b 2} [:b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2 :B 3} :c 3} [:a :b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2} :c 3} [:a :b])\n~~~\n  "],"~$split-by-predicate-positions",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",396,"^P",7,"^Q",396,"^R",35,"^S",["^T",["^U",["^T",[["~$coll","~$pred","~$n","~$d"]]]]],"^V","\n  Optimized version of `split-by-predicate` where we assume that the data is from a signal that we can sample.\n\n  Instead of checking each element, we check 1 over `n` elements.\n\n We return the positions where the data splits.\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.001))]\n    (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 10))\n~~~\n\n  The following assertion holds:\n\n~~~clojure\n  (= (split-by-predicate coll pred n)\n     (map #(apply subsequence data %) (split-by-predicate-positions coll pred n 1)))\n~~~\n\n  Here is an example:\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.01))]\n    (= (split-by-predicate data #(<= -0.01 % 0.01) 2)\n       (map #(apply subsequence data %) (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 1))))\n~~~\n  "],"^B","~$gadjett.collections/split-by-predicate-positions","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",35,"^X",["^T",[["^1D","^1E","~$n","~$d"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",396,"^10","~$cljs.core/LazySeq","^Q",396,"^12",4,"^13",true,"^S",["^T",["^U",["^T",[["^1D","^1E","~$n","~$d"]]]]],"^V","\n  Optimized version of `split-by-predicate` where we assume that the data is from a signal that we can sample.\n\n  Instead of checking each element, we check 1 over `n` elements.\n\n We return the positions where the data splits.\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.001))]\n    (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 10))\n~~~\n\n  The following assertion holds:\n\n~~~clojure\n  (= (split-by-predicate coll pred n)\n     (map #(apply subsequence data %) (split-by-predicate-positions coll pred n 1)))\n~~~\n\n  Here is an example:\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.01))]\n    (= (split-by-predicate data #(<= -0.01 % 0.01) 2)\n       (map #(apply subsequence data %) (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 1))))\n~~~\n  "],"~$mapify",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",317,"^P",7,"^Q",317,"^R",13,"^S",["^T",["^U",["^T",[["~$f","~$s"]]]]],"^V","\n  Takes a seq, and returns a map where the keys are the result of applying f to the elements in the seq.\n  The result of f should be unique for each element in the seq, otherwise you will loose some data.\n  If it is not unique, consider using [group-by](https://clojuredocs.org/clojure.core/group-by).\n\n~~~klipse\n  (mapify inc (range 5) )\n~~~\n  "],"^B","~$gadjett.collections/mapify","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",13,"^X",["^T",[["~$f","~$s"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",317,"^10","^16","^Q",317,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["~$f","~$s"]]]]],"^V","\n  Takes a seq, and returns a map where the keys are the result of applying f to the elements in the seq.\n  The result of f should be unique for each element in the seq, otherwise you will loose some data.\n  If it is not unique, consider using [group-by](https://clojuredocs.org/clojure.core/group-by).\n\n~~~klipse\n  (mapify inc (range 5) )\n~~~\n  "],"~$submap?",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",429,"^P",7,"^Q",429,"^R",14,"^S",["^T",["^U",["^T",[["~$m1","~$m2"]]]]],"^V","Checks if `m1` is a submap of `m2`.\n  Map `m1` is a submap of `m2` if all key/value pairs in `m1` exist in `m2`.\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2})\n~~~\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2 :c nil})\n~~~\n  "],"^B","~$gadjett.collections/submap?","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",14,"^X",["^T",[["^1K","^1L"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",429,"^10","~$boolean","^Q",429,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["^1K","^1L"]]]]],"^V","Checks if `m1` is a submap of `m2`.\n  Map `m1` is a submap of `m2` if all key/value pairs in `m1` exist in `m2`.\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2})\n~~~\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2 :c nil})\n~~~\n  "],"~$positions",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",365,"^P",7,"^Q",365,"^R",16,"^S",["^T",["^U",["^T",[["~$coll-of-lengths","~$&",["^ ","~:keys",["~$max-val","~$first-val"],"~:or",["^ ","^1R","~$infinity","^1S",0]]]]]]],"^V","Receives a collection of lengths and returns a list of start and end positions. Options:\n  * `max-val`: (default `infinity`) - max value for `end`\n  * `first-val`: (default 0) - first value of `start`\n\n~~~klipse\n  (positions '(10 10 20) :first-val 100 :max-val 137)\n~~~\n\n  ","~:top-fn",["^ ","^[",true,"~:fixed-arity",1,"^12",1,"^X",[["^T",["^1P",["^ ","^1Q",["^1R","^1S"],"^1T",["^ ","^1R","^1U","^1S",0]]]]],"^S",["^T",[["^1P","~$&",["^ ","^1Q",["^1R","^1S"],"^1T",["^ ","^1R","^1U","^1S",0]]]]],"^Z",["^T",[null]]]],"^B","~$gadjett.collections/positions","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",16,"^1V",["^ ","^[",true,"^1W",1,"^12",1,"^X",[["^T",["^1P",["^ ","^1Q",["^1R","^1S"],"^1T",["^ ","^1R","^1U","^1S",0]]]]],"^S",["^T",[["^1P","~$&",["^ ","^1Q",["^1R","^1S"],"^1T",["^ ","^1R","^1U","^1S",0]]]]],"^Z",["^T",[null]]],"^X",[["^T",["^1P",["^ ","^1Q",["^1R","^1S"],"^1T",["^ ","^1R","^1U","^1S",0]]]]],"^Y",null,"^1W",1,"^Z",["^T",[null]],"^P",1,"^[",true,"~:methods",[["^ ","^1W",1,"^[",true,"~:tag","^1G"]],"^O",365,"^10","^11","^Q",365,"^12",1,"^13",true,"^S",["^T",[["^1P","~$&",["^ ","^1Q",["^1R","^1S"],"^1T",["^ ","^1R","^1U","^1S",0]]]]],"^V","Receives a collection of lengths and returns a list of start and end positions. Options:\n  * `max-val`: (default `infinity`) - max value for `end`\n  * `first-val`: (default 0) - first value of `start`\n\n~~~klipse\n  (positions '(10 10 20) :first-val 100 :max-val 137)\n~~~\n\n  "],"~$filter-map",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",267,"^P",7,"^Q",267,"^R",17,"^S",["^T",["^U",["^T",[["~$f","~$m"]]]]],"^V","Run a function on the values of a map and keep only the (key, value) pairs for which the function returns true\n  \n~~~klipse\n  (filter-map even? {:a 1 :b 2 :c 3})\n~~~\n  "],"^B","~$gadjett.collections/filter-map","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",17,"^X",["^T",[["~$f","~$m"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",267,"^10",["^A",[null,"^16","^11"]],"^Q",267,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["~$f","~$m"]]]]],"^V","Run a function on the values of a map and keep only the (key, value) pairs for which the function returns true\n  \n~~~klipse\n  (filter-map even? {:a 1 :b 2 :c 3})\n~~~\n  "],"~$vec->map",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",47,"^P",7,"^Q",47,"^R",15,"^S",["^T",["^U",["^T",[["~$vec"]]]]],"^V","Converts a 2d vec to a hash-map.\n\n~~~klipse\n   (vec->map [[:a 1] [:b 2]])\n~~~\n   "],"^B","~$gadjett.collections/vec->map","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",15,"^X",["^T",[["^22"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",47,"^10",["^A",[null,"^16","^11"]],"^Q",47,"^12",1,"^13",true,"^S",["^T",["^U",["^T",[["^22"]]]]],"^V","Converts a 2d vec to a hash-map.\n\n~~~klipse\n   (vec->map [[:a 1] [:b 2]])\n~~~\n   "],"~$assoc-cyclic",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",205,"^P",7,"^Q",205,"^R",19,"^S",["^T",["^U",["^T",[["^1D","~$k","~$v"],["^1D","~$k","~$v","~$n"]]]]],"^V","Assoc a key-value pair to a map popping out an element of the map.\n  If the key already exists, no element is popped out.\n  If `n` is supplied, no elmement is popped out if the map has less than `n` entries.\n\n~~~klipse\n  (-> {:a 1 :b 2 :c 3}\n      (assoc-cyclic :d 4)\n      (assoc-cyclic :e 5)\n      (assoc-cyclic :f 6)\n      (assoc-cyclic :g 7))\n~~~\n  ","^1V",["^ ","^[",false,"^1W",4,"^12",4,"^X",["^T",[["^1D","~$k","~$v"],["^1D","~$k","~$v","~$n"]]],"^S",["^T",[["^1D","~$k","~$v"],["^1D","~$k","~$v","~$n"]]],"^Z",["^T",[null,null]]]],"^B","~$gadjett.collections/assoc-cyclic","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",19,"^1V",["^ ","^[",false,"^1W",4,"^12",4,"^X",["^T",[["^1D","~$k","~$v"],["^1D","~$k","~$v","~$n"]]],"^S",["^T",[["^1D","~$k","~$v"],["^1D","~$k","~$v","~$n"]]],"^Z",["^T",[null,null]]],"^X",["^T",[["^1D","~$k","~$v"],["^1D","~$k","~$v","~$n"]]],"^Y",null,"^1W",4,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^1Y",[["^ ","^1W",3,"^[",false,"^1Z",["^A",[null,"^16","^11"]]],["^ ","^1W",4,"^[",false,"^1Z",["^A",[null,"^16","^11"]]]],"^O",205,"^Q",205,"^12",4,"^13",true,"^S",["^T",[["^1D","~$k","~$v"],["^1D","~$k","~$v","~$n"]]],"^V","Assoc a key-value pair to a map popping out an element of the map.\n  If the key already exists, no element is popped out.\n  If `n` is supplied, no elmement is popped out if the map has less than `n` entries.\n\n~~~klipse\n  (-> {:a 1 :b 2 :c 3}\n      (assoc-cyclic :d 4)\n      (assoc-cyclic :e 5)\n      (assoc-cyclic :f 6)\n      (assoc-cyclic :g 7))\n~~~\n  "],"^1U",["^ ","^B","~$gadjett.collections/infinity","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^O",7,"^P",1,"^Q",7,"^R",14,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",7,"^P",6,"^Q",7,"^R",14],"^1Z","~$js"],"~$subsequence",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",444,"^P",7,"^Q",444,"^R",18,"^S",["^T",["^U",["^T",[["^1D","~$start","~$end"]]]]],"^V","\n  Returns a lazy subsequence of `coll`, starting at `start, ending at `end` (not included).\n\n~~~klipse\n  (subsequence (range) 10 20)\n~~~\n  "],"^B","~$gadjett.collections/subsequence","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",18,"^X",["^T",[["^1D","^29","^2:"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",444,"^10","^1G","^Q",444,"^12",3,"^13",true,"^S",["^T",["^U",["^T",[["^1D","^29","^2:"]]]]],"^V","\n  Returns a lazy subsequence of `coll`, starting at `start, ending at `end` (not included).\n\n~~~klipse\n  (subsequence (range) 10 20)\n~~~\n  "],"~$edn-zip",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",625,"^P",7,"^Q",625,"^R",14,"^S",["^T",["^U",["^T",[["~$root"]]]]],"^V","A zipper for `edn`.\n\n~~~klipse\n  (edn-zip {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"^B","~$gadjett.collections/edn-zip","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",14,"^X",["^T",[["^2="]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",625,"^10","^11","^Q",625,"^12",1,"^13",true,"^S",["^T",["^U",["^T",[["^2="]]]]],"^V","A zipper for `edn`.\n\n~~~klipse\n  (edn-zip {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"~$fix-blank-lines",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",691,"^P",7,"^Q",691,"^R",22,"^S",["^T",["^U",["^T",[["~$s"]]]]],"^V","Removes blank lines from the begining and from the end (not from the middle)\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (fix-blank-lines lines))\n~~~\n  "],"^B","~$gadjett.collections/fix-blank-lines","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",22,"^X",["^T",[["~$s"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",691,"^10","^11","^Q",691,"^12",1,"^13",true,"^S",["^T",["^U",["^T",[["~$s"]]]]],"^V","Removes blank lines from the begining and from the end (not from the middle)\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (fix-blank-lines lines))\n~~~\n  "],"~$map-to-object",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",307,"^P",7,"^Q",307,"^R",20,"^S",["^T",["^U",["^T",[["~$f","~$lst"]]]]],"^V","Returns a map whose keys are the elements of `lst` and values are mapped by `f`.\n\n~~~klipse\n  (map-to-object inc (range 5))\n~~~\n  "],"^B","~$gadjett.collections/map-to-object","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",20,"^X",["^T",[["~$f","^2B"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",307,"^10","^16","^Q",307,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["~$f","^2B"]]]]],"^V","Returns a map whose keys are the elements of `lst` and values are mapped by `f`.\n\n~~~klipse\n  (map-to-object inc (range 5))\n~~~\n  "],"~$deep-merge",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",524,"^P",7,"^Q",524,"^R",17,"^S",["^T",["^U",["^T",[["~$&","~$maps"]]]]],"^V"," Deep merges maps.\n\n~~~klipse\n(deep-merge {} {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}} {:a {:b 1}, :c {:e 4, :d 2000, :f {:g 9000}}})\n~~~\n","^1V",["^ ","^[",true,"^1W",0,"^12",0,"^X",[["^T",["^2E"]]],"^S",["^T",[["~$&","^2E"]]],"^Z",["^T",[null]]]],"^B","~$gadjett.collections/deep-merge","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",17,"^1V",["^ ","^[",true,"^1W",0,"^12",0,"^X",[["^T",["^2E"]]],"^S",["^T",[["~$&","^2E"]]],"^Z",["^T",[null]]],"^X",[["^T",["^2E"]]],"^Y",null,"^1W",0,"^Z",["^T",[null]],"^P",1,"^[",true,"^1Y",[["^ ","^1W",0,"^[",true,"^1Z","^11"]],"^O",524,"^10","^11","^Q",524,"^12",0,"^13",true,"^S",["^T",[["~$&","^2E"]]],"^V"," Deep merges maps.\n\n~~~klipse\n(deep-merge {} {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}} {:a {:b 1}, :c {:e 4, :d 2000, :f {:g 9000}}})\n~~~\n"],"~$mean",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",124,"^P",7,"^Q",124,"^R",11,"^S",["^T",["^U",["^T",[["~$x"]]]]],"^V","Calculates the mean (a.k.a average) of a sequence of numbers.\n\n~~~klipse\n  (mean [1 2 10 -1 12.3])\n~~~\n  "],"^B","~$gadjett.collections/mean","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",11,"^X",["^T",[["~$x"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",124,"^10","~$number","^Q",124,"^12",1,"^13",true,"^S",["^T",["^U",["^T",[["~$x"]]]]],"^V","Calculates the mean (a.k.a average) of a sequence of numbers.\n\n~~~klipse\n  (mean [1 2 10 -1 12.3])\n~~~\n  "],"~$loc-my-replace",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",650,"^P",8,"^Q",650,"^R",22,"~:private",true,"^S",["^T",["^U",["^T",[["~$smap","~$loc"]]]]]],"^2K",true,"^B","~$gadjett.collections/loc-my-replace","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",22,"^X",["^T",[["^2L","^2M"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",650,"^10",["^A",[null,"^11"]],"^Q",650,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["^2L","^2M"]]]]]],"~$map-object-kv",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",100,"^P",7,"^Q",100,"^R",20,"^S",["^T",["^U",["^T",[["~$fk","~$fv","~$m"]]]]],"^V","Returns a map with the keys mapped by `fk` and the values mapped by `fv`.\n\n~~~klipse\n    (map-object-kv name inc {:a 1 :b 2 :c 3})\n~~~\n"],"^B","~$gadjett.collections/map-object-kv","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",20,"^X",["^T",[["^2P","^2Q","~$m"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",100,"^10",["^A",[null,"^16","^11"]],"^Q",100,"^12",3,"^13",true,"^S",["^T",["^U",["^T",[["^2P","^2Q","~$m"]]]]],"^V","Returns a map with the keys mapped by `fk` and the values mapped by `fv`.\n\n~~~klipse\n    (map-object-kv name inc {:a 1 :b 2 :c 3})\n~~~\n"],"~$compactize-map-recursive",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",251,"^P",7,"^Q",251,"^R",31,"^S",["^T",["^U",["^T",[["~$m"]]]]],"^V","Remove from a map the entries whose values are `nil`.\n  If all the values of a nested map are `nil` the entrie is removed.\n~~~klipse\n\n(compactize-map-recursive {:x 1 :z {:a nil} :a {:b nil :c 2 :d {:e nil :f 2}}})\n~~~\n  "],"^B","~$gadjett.collections/compactize-map-recursive","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",31,"^X",["^T",[["~$m"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",251,"^10","^11","^Q",251,"^12",1,"^13",true,"^S",["^T",["^U",["^T",[["~$m"]]]]],"^V","Remove from a map the entries whose values are `nil`.\n  If all the values of a nested map are `nil` the entrie is removed.\n~~~klipse\n\n(compactize-map-recursive {:x 1 :z {:a nil} :a {:b nil :c 2 :d {:e nil :f 2}}})\n~~~\n  "],"~$flatten-keys",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",474,"^P",7,"^Q",474,"^R",19,"^S",["^T",["^U",["^T",[["~$m"]]]]],"^V","\nFlatten the keys of a nested map.\nThanks to [Jay Fields](http://blog.jayfields.com/2010/09/clojure-flatten-keys.html)\n\n~~~klipse\n(flatten-keys {:a {:b 1} :c {:d 2 :e 4 :f {:g 8}}})\n~~~\n"],"^B","~$gadjett.collections/flatten-keys","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",19,"^X",["^T",[["~$m"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",474,"^10",["^A",[null,"^16","^11","~$cljs.core/IMap"]],"^Q",474,"^12",1,"^13",true,"^S",["^T",["^U",["^T",[["~$m"]]]]],"^V","\nFlatten the keys of a nested map.\nThanks to [Jay Fields](http://blog.jayfields.com/2010/09/clojure-flatten-keys.html)\n\n~~~klipse\n(flatten-keys {:a {:b 1} :c {:d 2 :e 4 :f {:g 8}}})\n~~~\n"],"~$scale",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",21,"^P",8,"^Q",21,"^R",13,"^2K",true,"^S",["^T",["^U",["^T",[["~$x","~$y"]]]]]],"^2K",true,"^B","~$gadjett.collections/scale","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",13,"^X",["^T",[["~$x","~$y"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",21,"^10",["^A",["^11","^2I"]],"^Q",21,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["~$x","~$y"]]]]]],"~$flatten-keys*",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",467,"^P",8,"^Q",467,"^R",21,"^2K",true,"^S",["^T",["^U",["^T",[["~$a","^1=","~$m"]]]]]],"^2K",true,"^B","~$gadjett.collections/flatten-keys*","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",21,"^X",["^T",[["~$a","^1=","~$m"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",467,"^10",["^A",[null,"^16","^11","^2W"]],"^Q",467,"^12",3,"^13",true,"^S",["^T",["^U",["^T",[["~$a","^1=","~$m"]]]]]],"~$almost=",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",26,"^P",7,"^Q",26,"^R",14,"^S",["^T",["^U",["^T",[["~$x","~$y"],["~$x","~$y","~$epsilon"]]]]],"^1V",["^ ","^[",false,"^1W",3,"^12",3,"^X",["^T",[["~$x","~$y"],["~$x","~$y","^31"]]],"^S",["^T",[["~$x","~$y"],["~$x","~$y","^31"]]],"^Z",["^T",[null,null]]]],"^B","~$gadjett.collections/almost=","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",14,"^1V",["^ ","^[",false,"^1W",3,"^12",3,"^X",["^T",[["~$x","~$y"],["~$x","~$y","^31"]]],"^S",["^T",[["~$x","~$y"],["~$x","~$y","^31"]]],"^Z",["^T",[null,null]]],"^X",["^T",[["~$x","~$y"],["~$x","~$y","^31"]]],"^Y",null,"^1W",3,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^1Y",[["^ ","^1W",2,"^[",false,"^1Z","^11"],["^ ","^1W",3,"^[",false,"^1Z","^1N"]],"^O",26,"^Q",26,"^12",3,"^13",true,"^S",["^T",[["~$x","~$y"],["~$x","~$y","^31"]]]],"~$compactize-map",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",239,"^P",7,"^Q",239,"^R",21,"^S",["^T",["^U",["^T",[["~$m"]]]]],"^V","Removes entries with `nil` values.\n\n~~~klipse\n  (compactize-map {:a 1 :b nil :c 3})\n~~~\n  "],"^B","~$gadjett.collections/compactize-map","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",21,"^X",["^T",[["~$m"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",239,"^10",["^A",[null,"^16","^11"]],"^Q",239,"^12",1,"^13",true,"^S",["^T",["^U",["^T",[["~$m"]]]]],"^V","Removes entries with `nil` values.\n\n~~~klipse\n  (compactize-map {:a 1 :b nil :c 3})\n~~~\n  "],"~$partition-between",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",595,"^P",7,"^Q",595,"^R",24,"^S",["^T",["^U",["^T",[["^1E","^1D"]]]]],"^V","Splits a collection between two items according to predicate `pred` - which means split the sequence on breaking point.\n\n  See: [here](http://stackoverflow.com/questions/23207490/partition-a-seq-by-a-windowing-predicate-in-clojure)\n\n  For instance, split each time the series stop being ascending:\n\n~~~klipse\n(partition-between > [1 2 4 9 8 7 6 5 1 2 4 5 11])\n~~~\n"],"^B","~$gadjett.collections/partition-between","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",24,"^X",["^T",[["^1E","^1D"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",595,"^10","^1G","^Q",595,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["^1E","^1D"]]]]],"^V","Splits a collection between two items according to predicate `pred` - which means split the sequence on breaking point.\n\n  See: [here](http://stackoverflow.com/questions/23207490/partition-a-seq-by-a-windowing-predicate-in-clojure)\n\n  For instance, split each time the series stop being ascending:\n\n~~~klipse\n(partition-between > [1 2 4 9 8 7 6 5 1 2 4 5 11])\n~~~\n"],"~$take-from-map",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",496,"^P",7,"^Q",496,"^R",20,"^S",["^T",["^U",["^T",[["~$n","~$m"]]]]],"^V","Creates a map with n leaves which are nested values of m.\n  The following assertion holds:\n\n~~~clojure\n      (>= n (count (flatten-keys (take-from-map n m)))))))\n~~~\n\n~~~klipse\n  (take-from-map 3 {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"^B","~$gadjett.collections/take-from-map","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",20,"^X",["^T",[["~$n","~$m"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",496,"^10",["^A",[null,"^11"]],"^Q",496,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["~$n","~$m"]]]]],"^V","Creates a map with n leaves which are nested values of m.\n  The following assertion holds:\n\n~~~clojure\n      (>= n (count (flatten-keys (take-from-map n m)))))))\n~~~\n\n~~~klipse\n  (take-from-map 3 {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"~$map-nested-vals",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",760,"^P",7,"^Q",760,"^R",22,"^S",["^T",["^U",["^T",[["~$f","~$m"]]]]],"^V","Map the values of a nested map.\n~~~klipse\n  (map-nested-vals first {:a [1 2 3]\n                          :b {:c [4 5 6]}})\n~~~\n  "],"^B","~$gadjett.collections/map-nested-vals","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",22,"^X",["^T",[["~$f","~$m"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",760,"^10",["^A",[null,"^11"]],"^Q",760,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["~$f","~$m"]]]]],"^V","Map the values of a nested map.\n~~~klipse\n  (map-nested-vals first {:a [1 2 3]\n                          :b {:c [4 5 6]}})\n~~~\n  "],"~$compact",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",724,"^P",11,"^Q",724,"^R",18,"^S",["^T",["^U",["^T",[["~$x","~$&",["^ ","^1Q",["~$max-elements-in-coll","~$max-chars-in-str"],"^1T",["^ ","^3<",10,"^3=",20],"^1>","~$args"]]]]]],"^V","\n(clojurescript only)\n\nCompacts an expression by taking only the first `max-elements-in-coll` from collections and first `max-chars-in-str` from strings. Functions are displayed as \"lambda()\".\n\nIt works recursively. It is useful for logging and reporting.\n\nDefault settings:\n\n- `max-elements-in-coll` 10\n- `max-chars-in-str` 20\n\n~~~klipse\n(compact {:infinite-list (range)\n          :long-str \"a very very very very long string - too long to be true\"\n                                                      :long-map (zipmap (range 100) (range 100))\n                                                        :function #(+ 1 2)})\n~~~\n                  ","^1V",["^ ","^[",true,"^1W",1,"^12",1,"^X",[["^T",["~$x",["^ ","^1Q",["^3<","^3="],"^1T",["^ ","^3<",10,"^3=",20],"^1>","^3>"]]]],"^S",["^T",[["~$x","~$&",["^ ","^1Q",["^3<","^3="],"^1T",["^ ","^3<",10,"^3=",20],"^1>","^3>"]]]],"^Z",["^T",[null]]]],"^B","~$gadjett.collections/compact","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",18,"^1V",["^ ","^[",true,"^1W",1,"^12",1,"^X",[["^T",["~$x",["^ ","^1Q",["^3<","^3="],"^1T",["^ ","^3<",10,"^3=",20],"^1>","^3>"]]]],"^S",["^T",[["~$x","~$&",["^ ","^1Q",["^3<","^3="],"^1T",["^ ","^3<",10,"^3=",20],"^1>","^3>"]]]],"^Z",["^T",[null]]],"^X",[["^T",["~$x",["^ ","^1Q",["^3<","^3="],"^1T",["^ ","^3<",10,"^3=",20],"^1>","^3>"]]]],"^Y",null,"^1W",1,"^Z",["^T",[null]],"^P",5,"^[",true,"^1Y",[["^ ","^1W",1,"^[",true,"^1Z",["^A",[null,"^11","~$cljs.core/Keyword","^1G","^2I","~$string","^1B"]]]],"^O",724,"^10","^11","^Q",724,"^12",1,"^13",true,"^S",["^T",[["~$x","~$&",["^ ","^1Q",["^3<","^3="],"^1T",["^ ","^3<",10,"^3=",20],"^1>","^3>"]]]],"^V","\n(clojurescript only)\n\nCompacts an expression by taking only the first `max-elements-in-coll` from collections and first `max-chars-in-str` from strings. Functions are displayed as \"lambda()\".\n\nIt works recursively. It is useful for logging and reporting.\n\nDefault settings:\n\n- `max-elements-in-coll` 10\n- `max-chars-in-str` 20\n\n~~~klipse\n(compact {:infinite-list (range)\n          :long-str \"a very very very very long string - too long to be true\"\n                                                      :long-map (zipmap (range 100) (range 100))\n                                                        :function #(+ 1 2)})\n~~~\n                  "],"~$substr",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",790,"^P",7,"^Q",790,"^R",13,"^S",["^T",["^U",["^T",[["~$s","^29"],["~$s","^29","^2:"]]]]],"^V","Like clojure.core/subs but prevents some exceptions when the `start` or `end` are out of bound.\n~~~klipse\n  (subs \"\" -2)\n~~~\n\n  ","^1V",["^ ","^[",false,"^1W",3,"^12",3,"^X",["^T",[["~$s","^29"],["~$s","^29","^2:"]]],"^S",["^T",[["~$s","^29"],["~$s","^29","^2:"]]],"^Z",["^T",[null,null]]]],"^B","~$gadjett.collections/substr","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",13,"^1V",["^ ","^[",false,"^1W",3,"^12",3,"^X",["^T",[["~$s","^29"],["~$s","^29","^2:"]]],"^S",["^T",[["~$s","^29"],["~$s","^29","^2:"]]],"^Z",["^T",[null,null]]],"^X",["^T",[["~$s","^29"],["~$s","^29","^2:"]]],"^Y",null,"^1W",3,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^1Y",[["^ ","^1W",2,"^[",false,"^1Z","^11"],["^ ","^1W",3,"^[",false,"^1Z","^11"]],"^O",790,"^Q",790,"^12",3,"^13",true,"^S",["^T",[["~$s","^29"],["~$s","^29","^2:"]]],"^V","Like clojure.core/subs but prevents some exceptions when the `start` or `end` are out of bound.\n~~~klipse\n  (subs \"\" -2)\n~~~\n\n  "],"~$map-with-index",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",330,"^P",7,"^Q",330,"^R",21,"^S",["^T",["^U",["^T",[["~$s","~$idx-key","~$val-key"]]]]],"^V","Maps a sequence to a sequence of maps with index and value\n\n~~~klipse\n      (map-with-index [10 20 30] :idx :val)\n~~~\n  "],"^B","~$gadjett.collections/map-with-index","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",21,"^X",["^T",[["~$s","^3E","^3F"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",330,"^10","^11","^Q",330,"^12",3,"^13",true,"^S",["^T",["^U",["^T",[["~$s","^3E","^3F"]]]]],"^V","Maps a sequence to a sequence of maps with index and value\n\n~~~klipse\n      (map-with-index [10 20 30] :idx :val)\n~~~\n  "],"~$map-object-with-key",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",90,"^P",7,"^Q",90,"^R",26,"^S",["^T",["^U",["^T",[["~$f","~$m"]]]]],"^V","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` must be a `2-ary` function that receives the key and the value as arguments.\n\n~~~klipse\n  (map-object-with-key list {:a 1 :b 2 :c 3})\n~~~\n  "],"^B","~$gadjett.collections/map-object-with-key","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",26,"^X",["^T",[["~$f","~$m"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",90,"^10",["^A",[null,"^16","^11"]],"^Q",90,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["~$f","~$m"]]]]],"^V","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` must be a `2-ary` function that receives the key and the value as arguments.\n\n~~~klipse\n  (map-object-with-key list {:a 1 :b 2 :c 3})\n~~~\n  "],"~$deep-merge*",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",515,"^P",8,"^Q",515,"^R",19,"^2K",true,"^S",["^T",["^U",["^T",[["~$&","^2E"]]]]],"^1V",["^ ","^[",true,"^1W",0,"^12",0,"^X",[["^T",["^2E"]]],"^S",["^T",[["~$&","^2E"]]],"^Z",["^T",[null]]]],"^2K",true,"^B","~$gadjett.collections/deep-merge*","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",19,"^1V",["^ ","^[",true,"^1W",0,"^12",0,"^X",[["^T",["^2E"]]],"^S",["^T",[["~$&","^2E"]]],"^Z",["^T",[null]]],"^X",[["^T",["^2E"]]],"^Y",null,"^1W",0,"^Z",["^T",[null]],"^P",1,"^[",true,"^1Y",[["^ ","^1W",0,"^[",true,"^1Z",["^A",["^11","^1B"]]]],"^O",515,"^10","^11","^Q",515,"^12",0,"^13",true,"^S",["^T",[["~$&","^2E"]]]],"~$range-till-end",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",169,"^P",7,"^Q",169,"^R",21,"^S",["^T",["^U",["^T",[["~$&","^3>"]]]]],"^V","Like `range` but including the `end`.\n\n~~~klipse\n  (range-till-end 10)\n~~~\n\n~~~klipse\n(range-till-end 10 18)\n~~~\n\n~~~klipse\n(range-till-end 10 100 5)\n~~~\n\n  ","^1V",["^ ","^[",true,"^1W",0,"^12",0,"^X",[["^T",["^3>"]]],"^S",["^T",[["~$&","^3>"]]],"^Z",["^T",[null]]]],"^B","~$gadjett.collections/range-till-end","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",21,"^1V",["^ ","^[",true,"^1W",0,"^12",0,"^X",[["^T",["^3>"]]],"^S",["^T",[["~$&","^3>"]]],"^Z",["^T",[null]]],"^X",[["^T",["^3>"]]],"^Y",null,"^1W",0,"^Z",["^T",[null]],"^P",1,"^[",true,"^1Y",[["^ ","^1W",0,"^[",true,"^1Z","^1G"]],"^O",169,"^10","^11","^Q",169,"^12",0,"^13",true,"^S",["^T",[["~$&","^3>"]]],"^V","Like `range` but including the `end`.\n\n~~~klipse\n  (range-till-end 10)\n~~~\n\n~~~klipse\n(range-till-end 10 18)\n~~~\n\n~~~klipse\n(range-till-end 10 100 5)\n~~~\n\n  "],"~$nearest-of-seq",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",294,"^P",7,"^Q",294,"^R",21,"^S",["^T",["^U",["^T",[["~$a","~$b"]]]]],"^V","Maps each element of `b` to its nearest element in `a`.\n  If `a` is empty, returns `b`.\n\n~~~klipse\n  (nearest-of-seq (range 5) [1.2 3.4 4])\n~~~\n  "],"^B","~$gadjett.collections/nearest-of-seq","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",21,"^X",["^T",[["~$a","~$b"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",294,"^10",["^A",[null,"^1G"]],"^Q",294,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["~$a","~$b"]]]]],"^V","Maps each element of `b` to its nearest element in `a`.\n  If `a` is empty, returns `b`.\n\n~~~klipse\n  (nearest-of-seq (range 5) [1.2 3.4 4])\n~~~\n  "],"~$range-with-end",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",164,"^P",8,"^Q",164,"^R",22,"^2K",true,"^S",["^T",["^U",["^T",[["^2:"],["^29","^2:"],["^29","^2:","~$steps"]]]]],"^1V",["^ ","^[",false,"^1W",3,"^12",3,"^X",["^T",[["^2:"],["^29","^2:"],["^29","^2:","^3Q"]]],"^S",["^T",[["^2:"],["^29","^2:"],["^29","^2:","^3Q"]]],"^Z",["^T",[null,null,null]]]],"^2K",true,"^B","~$gadjett.collections/range-with-end","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",22,"^1V",["^ ","^[",false,"^1W",3,"^12",3,"^X",["^T",[["^2:"],["^29","^2:"],["^29","^2:","^3Q"]]],"^S",["^T",[["^2:"],["^29","^2:"],["^29","^2:","^3Q"]]],"^Z",["^T",[null,null,null]]],"^X",["^T",[["^2:"],["^29","^2:"],["^29","^2:","^3Q"]]],"^Y",null,"^1W",3,"^Z",["^T",[null,null,null]],"^P",1,"^[",false,"^1Y",[["^ ","^1W",1,"^[",false,"^1Z","~$cljs.core/IVector"],["^ ","^1W",2,"^[",false,"^1Z","^3S"],["^ ","^1W",3,"^[",false,"^1Z","^3S"]],"^O",164,"^Q",164,"^12",3,"^13",true,"^S",["^T",[["^2:"],["^29","^2:"],["^29","^2:","^3Q"]]]],"~$branches-and-leaves",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",559,"^P",7,"^Q",559,"^R",26,"^S",["^T",["^U",["^T",[["~$m"]]]]],"^V","Returns all branches and leaves off a nested map object.\n\n~~~klipse\n(branches-and-leaves {:a {:b 1 :c {:d 2}} :e 3})\n~~~\n  "],"^B","~$gadjett.collections/branches-and-leaves","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",26,"^X",["^T",[["~$m"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",559,"^10",["^A",[null,"^11"]],"^Q",559,"^12",1,"^13",true,"^S",["^T",["^U",["^T",[["~$m"]]]]],"^V","Returns all branches and leaves off a nested map object.\n\n~~~klipse\n(branches-and-leaves {:a {:b 1 :c {:d 2}} :e 3})\n~~~\n  "],"~$deep-merge-with",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",545,"^P",7,"^Q",545,"^R",22,"^S",["^T",["^U",["^T",[["~$g","~$&","^2E"]]]]],"^V","Like merge-with but deep.\n~~~klipse\n(deep-merge-with concat\n                 {:x {:b [1]\n                      :a [1]}}\n                 {:x {:a [3 4]}})\n~~~\n","^1V",["^ ","^[",true,"^1W",1,"^12",1,"^X",[["^T",["~$g","^2E"]]],"^S",["^T",[["~$g","~$&","^2E"]]],"^Z",["^T",[null]]]],"^B","~$gadjett.collections/deep-merge-with","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",22,"^1V",["^ ","^[",true,"^1W",1,"^12",1,"^X",[["^T",["~$g","^2E"]]],"^S",["^T",[["~$g","~$&","^2E"]]],"^Z",["^T",[null]]],"^X",[["^T",["~$g","^2E"]]],"^Y",null,"^1W",1,"^Z",["^T",[null]],"^P",1,"^[",true,"^1Y",[["^ ","^1W",1,"^[",true,"^1Z","^11"]],"^O",545,"^10","^11","^Q",545,"^12",1,"^13",true,"^S",["^T",[["~$g","~$&","^2E"]]],"^V","Like merge-with but deep.\n~~~klipse\n(deep-merge-with concat\n                 {:x {:b [1]\n                      :a [1]}}\n                 {:x {:a [3 4]}})\n~~~\n"],"~$remove-blank-lines",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",709,"^P",7,"^Q",709,"^R",25,"^S",["^T",["^U",["^T",[["~$s"]]]]],"^V","Removes blank lines.\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-blank-lines lines))\n~~~\n  "],"^B","~$gadjett.collections/remove-blank-lines","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",25,"^X",["^T",[["~$s"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",709,"^10","^11","^Q",709,"^12",1,"^13",true,"^S",["^T",["^U",["^T",[["~$s"]]]]],"^V","Removes blank lines.\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-blank-lines lines))\n~~~\n  "],"~$select-vals",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",809,"^P",7,"^Q",809,"^R",18,"^S",["^T",["^U",["^T",[["~$map","~$keyseq"]]]]]],"^B","~$gadjett.collections/select-vals","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",18,"^X",["^T",[["^3[","^40"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",809,"^10",["^A",["~$cljs.core/ValSeq","^1B"]],"^Q",809,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["^3[","^40"]]]]]],"~$sequence-of-maps->map",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",146,"^P",7,"^Q",146,"^R",28,"^S",["^T",["^U",["^T",[["^1D","~$key-fn","~$val-fn"]]]]],"^V","Converts a sequence of maps into a map where:\n\n  - the keys are extracted from the maps using `key-fn`\n  - the vals extracted from the maps using `val-fn`  \n  \n  ~~~klipse\n  (sequence-of-maps->map [{:key :price :value 19}\n                          {:key :quantity :value 100}]\n                          :key :value)\n  ~~~\n  "],"^B","~$gadjett.collections/sequence-of-maps->map","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",28,"^X",["^T",[["^1D","^44","^45"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",146,"^10",["^A",[null,"^11"]],"^Q",146,"^12",3,"^13",true,"^S",["^T",["^U",["^T",[["^1D","^44","^45"]]]]],"^V","Converts a sequence of maps into a map where:\n\n  - the keys are extracted from the maps using `key-fn`\n  - the vals extracted from the maps using `val-fn`  \n  \n  ~~~klipse\n  (sequence-of-maps->map [{:key :price :value 19}\n                          {:key :quantity :value 100}]\n                          :key :value)\n  ~~~\n  "],"~$filter-branches",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",573,"^P",7,"^Q",573,"^R",22,"^S",["^T",["^U",["^T",[["~$m","~$p"]]]]],"^V","Filters branches of a (nested) map `m` according to a predicate `m`.\n\n~~~klipse\n(filter-branches {:x {:id 19 :b 1 :c {:id 2}} :e 3} :id)\n~~~\n  "],"^B","~$gadjett.collections/filter-branches","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",22,"^X",["^T",[["~$m","~$p"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",573,"^10","^1G","^Q",573,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["~$m","~$p"]]]]],"^V","Filters branches of a (nested) map `m` according to a predicate `m`.\n\n~~~klipse\n(filter-branches {:x {:id 19 :b 1 :c {:id 2}} :e 3} :id)\n~~~\n  "],"~$select-keys-in-order",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",804,"^P",7,"^Q",804,"^R",27,"^S",["^T",["^U",["^T",[["~$m","^40"]]]]],"^V","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"],"^B","~$gadjett.collections/select-keys-in-order","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",27,"^X",["^T",[["~$m","^40"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",804,"^10","^1G","^Q",804,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["~$m","^40"]]]]],"^V","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"],"~$comment?",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",672,"^P",8,"^Q",672,"^R",16,"^2K",true,"^S",["^T",["^U",["^T",[["~$s"]]]]]],"^2K",true,"^B","~$gadjett.collections/comment?","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",16,"^X",["^T",[["~$s"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",672,"^10",["^A",["^16","^3S","^11","~$cljs.core/MetaFn","^1B"]],"^Q",672,"^12",1,"^13",true,"^S",["^T",["^U",["^T",[["~$s"]]]]]],"~$out-of-bound?",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",585,"^P",7,"^Q",585,"^R",20,"^S",["^T",["^U",["^T",[["~$v","~$idx"]]]]],"^V","Checks if index `idx` is in range of vector `v`. More efficient than `(get v idx)`\n\n~~~klipse\n    (map #(out-of-bound? [1 2 3] %) [-1 0 1 2 3 4])\n~~~\n  "],"^B","~$gadjett.collections/out-of-bound?","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",20,"^X",["^T",[["~$v","^4?"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",585,"^10","^1N","^Q",585,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["~$v","^4?"]]]]],"^V","Checks if index `idx` is in range of vector `v`. More efficient than `(get v idx)`\n\n~~~klipse\n    (map #(out-of-bound? [1 2 3] %) [-1 0 1 2 3 4])\n~~~\n  "],"~$map-2d-vec",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",57,"^P",7,"^Q",57,"^R",17,"^S",["^T",["^U",["^T",[["~$f","~$m"]]]]],"^V","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-2d-vec inc [[:a 1] [:b 2]])\n~~~\n"],"^B","~$gadjett.collections/map-2d-vec","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",17,"^X",["^T",[["~$f","~$m"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",57,"^10","^1G","^Q",57,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["~$f","~$m"]]]]],"^V","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-2d-vec inc [[:a 1] [:b 2]])\n~~~\n"],"~$split-by-predicate",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",380,"^P",7,"^Q",380,"^R",25,"^S",["^T",["^U",["^T",[["^1D","^1E","~$n"]]]]],"^V","Splits a collection to items where the separator is a repetition of at least n elements that satisfy `pred`.\n\n  Inspired by: [this question](http://stackoverflow.com/a/23555616/813665).\n\n~~~klipse\n  (split-by-predicate (shuffle (range 30)) even? 2)\n~~~\n  "],"^B","~$gadjett.collections/split-by-predicate","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",25,"^X",["^T",[["^1D","^1E","~$n"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",380,"^10","^1G","^Q",380,"^12",3,"^13",true,"^S",["^T",["^U",["^T",[["^1D","^1E","~$n"]]]]],"^V","Splits a collection to items where the separator is a repetition of at least n elements that satisfy `pred`.\n\n  Inspired by: [this question](http://stackoverflow.com/a/23555616/813665).\n\n~~~klipse\n  (split-by-predicate (shuffle (range 30)) even? 2)\n~~~\n  "],"~$abs",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",10,"^P",7,"^Q",10,"^R",10,"^S",["^T",["^U",["^T",[["~$x"]]]]],"^V","Absolute value of a number\n\n~~~klipse\n  (map abs (range -5 5))\n~~~\n\n"],"^B","~$gadjett.collections/abs","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",10,"^X",["^T",[["~$x"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",10,"^10","^11","^Q",10,"^12",1,"^13",true,"^S",["^T",["^U",["^T",[["~$x"]]]]],"^V","Absolute value of a number\n\n~~~klipse\n  (map abs (range -5 5))\n~~~\n\n"],"~$deep-merge-with*",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",536,"^P",8,"^Q",536,"^R",24,"^2K",true,"^S",["^T",["^U",["^T",[["~$g","~$&","^2E"]]]]],"^1V",["^ ","^[",true,"^1W",1,"^12",1,"^X",[["^T",["~$g","^2E"]]],"^S",["^T",[["~$g","~$&","^2E"]]],"^Z",["^T",[null]]]],"^2K",true,"^B","~$gadjett.collections/deep-merge-with*","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",24,"^1V",["^ ","^[",true,"^1W",1,"^12",1,"^X",[["^T",["~$g","^2E"]]],"^S",["^T",[["~$g","~$&","^2E"]]],"^Z",["^T",[null]]],"^X",[["^T",["~$g","^2E"]]],"^Y",null,"^1W",1,"^Z",["^T",[null]],"^P",1,"^[",true,"^1Y",[["^ ","^1W",1,"^[",true,"^1Z","^11"]],"^O",536,"^10","^11","^Q",536,"^12",1,"^13",true,"^S",["^T",[["~$g","~$&","^2E"]]]],"~$join-them",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",773,"^P",7,"^Q",773,"^R",16,"^S",["^T",["^U",["^T",[["~$fns","~$colls"]]]]],"^V","Join a sequence of collections `colls` according to function equality.\n   `fns` - a sequence of functions\n   `colls` - a sequence of collections\n~~~klipse\n(let [a [{:id 1 :price 19} {:id 2 :price 3}]\n        b [{:guid 1 :quantity 13}]]\n     (join-them [:id :guid] [a b]))\n~~~\n"],"^B","~$gadjett.collections/join-them","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",16,"^X",["^T",[["^4J","^4K"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",773,"^10",["^A",["^42","^1B"]],"^Q",773,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["^4J","^4K"]]]]],"^V","Join a sequence of collections `colls` according to function equality.\n   `fns` - a sequence of functions\n   `colls` - a sequence of collections\n~~~klipse\n(let [a [{:id 1 :price 19} {:id 2 :price 3}]\n        b [{:guid 1 :quantity 13}]]\n     (join-them [:id :guid] [a b]))\n~~~\n"],"~$append-cyclic",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",189,"^P",7,"^Q",189,"^R",20,"^S",["^T",["^U",["^T",[["^2B","~$a"]]]]],"^V","Appends an element to a list popping out the first element.\n\n~~~klipse\n  (-> (repeat 3 nil)\n      (append-cyclic 1)\n      (append-cyclic 2)\n      (append-cyclic 3)\n      (append-cyclic 4))\n~~~\n  "],"^B","~$gadjett.collections/append-cyclic","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",20,"^X",["^T",[["^2B","~$a"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",189,"^10",["^A",[null,"^1G"]],"^Q",189,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["^2B","~$a"]]]]],"^V","Appends an element to a list popping out the first element.\n\n~~~klipse\n  (-> (repeat 3 nil)\n      (append-cyclic 1)\n      (append-cyclic 2)\n      (append-cyclic 3)\n      (append-cyclic 4))\n~~~\n  "],"~$select-vals-in-order",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",812,"^P",7,"^Q",812,"^R",27,"^S",["^T",["^U",["^T",[["^3[","^1="]]]]],"^V","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"],"^B","~$gadjett.collections/select-vals-in-order","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",27,"^X",["^T",[["^3[","^1="]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",812,"^10",["^A",[null,"^11"]],"^Q",812,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["^3[","^1="]]]]],"^V","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"],"~$collify",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",611,"^P",7,"^Q",611,"^R",14,"^S",["^T",["^U",["^T",[["~$s"]]]]],"^V","Ensure `s` is a collection: if `s` is a collection returns it; otherwise returns (s)\n\n~~~klipse\n(collify 1)\n~~~\n\n~~~klipse\n(collify [1 2 3])\n~~~\n  "],"^B","~$gadjett.collections/collify","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",14,"^X",["^T",[["~$s"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",611,"^10",["^A",[null,"~$cljs.core/List"]],"^Q",611,"^12",1,"^13",true,"^S",["^T",["^U",["^T",[["~$s"]]]]],"^V","Ensure `s` is a collection: if `s` is a collection returns it; otherwise returns (s)\n\n~~~klipse\n(collify 1)\n~~~\n\n~~~klipse\n(collify [1 2 3])\n~~~\n  "],"~$map-2d-vec-kv",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",68,"^P",7,"^Q",68,"^R",20,"^S",["^T",["^U",["^T",[["^2P","^2Q","~$m"]]]]],"^V","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`fk` is a `1-ary` function that receives the key.\n`fv` is a `1-ary` function that receives the value.\n\n~~~klipse\n    (map-2d-vec-kv name inc [[:a 1] [:b 2]])\n~~~\n"],"^B","~$gadjett.collections/map-2d-vec-kv","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",20,"^X",["^T",[["^2P","^2Q","~$m"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",68,"^10","^1G","^Q",68,"^12",3,"^13",true,"^S",["^T",["^U",["^T",[["^2P","^2Q","~$m"]]]]],"^V","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`fk` is a `1-ary` function that receives the key.\n`fv` is a `1-ary` function that receives the value.\n\n~~~klipse\n    (map-2d-vec-kv name inc [[:a 1] [:b 2]])\n~~~\n"],"~$max-and-min",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",227,"^P",7,"^Q",227,"^R",18,"^S",["^T",["^U",["^T",[["~$x"]]]]],"^V","Returns a couple of the `max` and the `min` of a sequence.\n\n~~~klipse\n  (max-and-min (range 5))\n~~~\n  "],"^B","~$gadjett.collections/max-and-min","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",18,"^X",["^T",[["~$x"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",227,"^10",["^A",["^3S","^11"]],"^Q",227,"^12",1,"^13",true,"^S",["^T",["^U",["^T",[["~$x"]]]]],"^V","Returns a couple of the `max` and the `min` of a sequence.\n\n~~~klipse\n  (max-and-min (range 5))\n~~~\n  "],"~$index-of",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",456,"^P",7,"^Q",456,"^R",15,"^S",["^T",["^U",["^T",[["~$s","~$element"]]]]],"^V","Returns the index of an element in a sequence or `-1` if not present.\n\n  ~~~klipse\n  (index-of (range 100) 18)\n  ~~~\n  "],"^B","~$gadjett.collections/index-of","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",15,"^X",["^T",[["~$s","^4Y"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",456,"^10",["^A",["^11","^2I"]],"^Q",456,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["~$s","^4Y"]]]]],"^V","Returns the index of an element in a sequence or `-1` if not present.\n\n  ~~~klipse\n  (index-of (range 100) 18)\n  ~~~\n  "],"~$nearest-of-ss",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",282,"^P",7,"^Q",282,"^R",20,"^S",["^T",["^U",["^T",[["~$ss","~$x"]]]]],"^V","Returns the nearest number to `x` of a sorted set\n\n~~~klipse\n  (nearest-of-ss (apply sorted-set (range 5)) 1.2)\n~~~\n  "],"^B","~$gadjett.collections/nearest-of-ss","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",20,"^X",["^T",[["^50","~$x"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",282,"^10","^11","^Q",282,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["^50","~$x"]]]]],"^V","Returns the nearest number to `x` of a sorted set\n\n~~~klipse\n  (nearest-of-ss (apply sorted-set (range 5)) 1.2)\n~~~\n  "],"~$map-reverse-hierarchy",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",110,"^P",7,"^Q",110,"^R",28,"^S",["^T",["^U",["^T",[["~$m"]]]]],"^V","Turns a hash map inside out.\n  See:  [here](http://stackoverflow.com/a/23653784/813665)\n\n~~~klipse\n  (map-reverse-hierarchy {:monday {:banana 2 :apple 3} \n                          :tuesday {:banana 5 :orange 2}})\n~~~\n"],"^B","~$gadjett.collections/map-reverse-hierarchy","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",28,"^X",["^T",[["~$m"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",110,"^10",["^A",["^11","^2W"]],"^Q",110,"^12",1,"^13",true,"^S",["^T",["^U",["^T",[["~$m"]]]]],"^V","Turns a hash map inside out.\n  See:  [here](http://stackoverflow.com/a/23653784/813665)\n\n~~~klipse\n  (map-reverse-hierarchy {:monday {:banana 2 :apple 3} \n                          :tuesday {:banana 5 :orange 2}})\n~~~\n"],"~$remove-ending-comments",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",675,"^P",7,"^Q",675,"^R",29,"^S",["^T",["^U",["^T",[["~$s"]]]]],"^V","Removes comment lines from the end.\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"aa\", \"  \", \"bb\" \"; this comment should not appear\"])]\n  (remove-ending-comments lines))\n~~~\n  "],"^B","~$gadjett.collections/remove-ending-comments","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",29,"^X",["^T",[["~$s"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",675,"^10","^11","^Q",675,"^12",1,"^13",true,"^S",["^T",["^U",["^T",[["~$s"]]]]],"^V","Removes comment lines from the end.\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"aa\", \"  \", \"bb\" \"; this comment should not appear\"])]\n  (remove-ending-comments lines))\n~~~\n  "],"~$map-object",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",80,"^P",7,"^Q",80,"^R",17,"^S",["^T",["^U",["^T",[["~$f","~$m"]]]]],"^V","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-object inc {:a 1 :b 2 :c 3})\n~~~\n  "],"^B","~$gadjett.collections/map-object","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",17,"^X",["^T",[["~$f","~$m"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",80,"^10",["^A",[null,"^16","^11"]],"^Q",80,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["~$f","~$m"]]]]],"^V","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-object inc {:a 1 :b 2 :c 3})\n~~~\n  "],"~$=set",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",33,"^P",8,"^Q",33,"^R",12,"^2K",true,"^S",["^T",["^U",["^T",[["~$a","~$b"]]]]]],"^2K",true,"^B","~$gadjett.collections/=set","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",12,"^X",["^T",[["~$a","~$b"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",33,"^10","^1N","^Q",33,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["~$a","~$b"]]]]]],"~$my-replace",["^ ","^L",null,"^M",["^ ","^N","/Users/viebel/prj/klipse-clj/target/public/cljs-out/standalone/gadjett/collections.cljc","^O",657,"^P",7,"^Q",657,"^R",17,"^S",["^T",["^U",["^T",[["^2L","~$form"]]]]],"^V","Recursively transforms `form` by replacing keys in `smap` with their\n  values, spliced. The values in `smap` must be sequences. Like clojure.walk/prewalk-replace but supports list in values.\n\n~~~klipse\n(my-replace '{go (go gadjett)} '(go (<! (timeout 100)) (go (<! timeout 0))))\n~~~\n  "],"^B","~$gadjett.collections/my-replace","^N","target/public/cljs-out/standalone/gadjett/collections.cljc","^R",17,"^X",["^T",[["^2L","^5;"]]],"^Y",null,"^Z",["^T",[null,null]],"^P",1,"^[",false,"^O",657,"^10","^11","^Q",657,"^12",2,"^13",true,"^S",["^T",["^U",["^T",[["^2L","^5;"]]]]],"^V","Recursively transforms `form` by replacing keys in `smap` with their\n  values, spliced. The values in `smap` must be sequences. Like clojure.walk/prewalk-replace but supports list in values.\n\n~~~klipse\n(my-replace '{go (go gadjett)} '(go (<! (timeout 100)) (go (<! timeout 0))))\n~~~\n  "]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^A",["~:max-elements-in-coll","~:else","~:max-chars-in-str","~:first-val","~:branches","~:leaves","~:max-val"]],"~:order",["^5G","^5D","^5E","^5F","^5A","^5C","^5B"]],"^V",null]