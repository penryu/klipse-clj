["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ ","~$postwalk","~$clojure.walk","~$union","~$clojure.set","~$join","~$clojure.string","~$split-lines","^8","~$blank?","^8"],"~:excludes",["~#set",["~$abs"]],"~:name","~$gadjett.collections","~:imports",null,"~:requires",["^ ","^6","^6","^4","^4","^8","^8","~$zip","~$clojure.zip","^C","^C"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","^3","^4","^5","^6","^7","^8","^9","^8","^:","^8"],"~:defs",["^ ","~$unflatten-keys",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","~:line",483,"~:column",7,"~:end-line",483,"~:end-column",21,"~:arglists",["~#list",["~$quote",["^P",[["~$m"]]]]],"~:doc","\n  Unflattend the keys of a map that has been `flatten-keys`ed.\n\n~~~klipse\n(unflatten-keys {[:a :b] 1, [:c :d] 2, [:c :e] 4, [:c :f :g] 8})\n~~~\n"],"^>","~$gadjett.collections/unflatten-keys","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",21,"~:method-params",["^P",[["~$m"]]],"~:protocol-impl",null,"~:arglists-meta",["^P",[null,null]],"^L",1,"~:variadic?",false,"^K",483,"~:ret-tag",["^<",[null,"~$any"]],"^M",483,"~:max-fixed-arity",1,"~:fn-var",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","\n  Unflattend the keys of a map that has been `flatten-keys`ed.\n\n~~~klipse\n(unflatten-keys {[:a :b] 1, [:c :d] 2, [:c :e] 4, [:c :f :g] 8})\n~~~\n"],"~$sequence->map",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",136,"^L",7,"^M",136,"^N",20,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Converts a sequence into a map where the keys are the indexes of the elements in the sequence.\n\n  ~~~klipse\n  (sequence->map [10 20 30])\n  ~~~\n  "],"^>","~$gadjett.collections/sequence->map","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",20,"^T",["^P",[["~$s"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",136,"^X","~$clj","^M",136,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Converts a sequence into a map where the keys are the indexes of the elements in the sequence.\n\n  ~~~klipse\n  (sequence->map [10 20 30])\n  ~~~\n  "],"~$=without-keys?",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",37,"^L",7,"^M",37,"^N",21,"^O",["^P",["^Q",["^P",[["~$obj-a","~$obj-b","~$keys-list"]]]]],"^R","Compare two maps exclusing some keys\n\n~~~klipse\n  (=without-keys? {:a 1 :b 2 :c 3} {:a 1 :b 5} #{:b :c})\n~~~\n  "],"^>","~$gadjett.collections/=without-keys?","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",21,"^T",["^P",[["^14","^15","^16"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",37,"^X","^Y","^M",37,"^Z",3,"^[",true,"^O",["^P",["^Q",["^P",[["^14","^15","^16"]]]]],"^R","Compare two maps exclusing some keys\n\n~~~klipse\n  (=without-keys? {:a 1 :b 2 :c 3} {:a 1 :b 5} #{:b :c})\n~~~\n  "],"~$dissoc-in",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",338,"^L",7,"^M",338,"^N",16,"^O",["^P",["^Q",["^P",[["~$m",["~$k","~$&","~$ks","~:as","~$keys"]]]]]],"^R","Dissociates an entry from a nested associative structure returning a new nested structure. `keys` is a sequence of keys. Any empty maps that result will not be present in the new structure. See [assoc-in](https://clojuredocs.org/clojure.core/assoc-in)\n\n~~~klipse\n  (dissoc-in {:a 1 :b 2} [:b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2 :B 3} :c 3} [:a :b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2} :c 3} [:a :b])\n~~~\n  "],"^>","~$gadjett.collections/dissoc-in","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",16,"^T",["^P",[["~$m","~$p__28800"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",338,"^X",["^<",[null,"^12","^Y","~$clj-nil"]],"^M",338,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$m",["~$k","~$&","^19","^1:","^1;"]]]]]],"^R","Dissociates an entry from a nested associative structure returning a new nested structure. `keys` is a sequence of keys. Any empty maps that result will not be present in the new structure. See [assoc-in](https://clojuredocs.org/clojure.core/assoc-in)\n\n~~~klipse\n  (dissoc-in {:a 1 :b 2} [:b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2 :B 3} :c 3} [:a :b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2} :c 3} [:a :b])\n~~~\n  "],"~$split-by-predicate-positions",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",394,"^L",7,"^M",394,"^N",35,"^O",["^P",["^Q",["^P",[["~$coll","~$pred","~$n","~$d"]]]]],"^R","\n  Optimized version of `split-by-predicate` where we assume that the data is from a signal that we can sample.\n\n  Instead of checking each element, we check 1 over `n` elements.\n\n We return the positions where the data splits.\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.001))]\n    (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 10))\n~~~\n\n  The following assertion holds:\n\n~~~clojure\n  (= (split-by-predicate coll pred n)\n     (map #(apply subsequence data %) (split-by-predicate-positions coll pred n 1)))\n~~~\n\n  Here is an example:\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.01))]\n    (= (split-by-predicate data #(<= -0.01 % 0.01) 2)\n       (map #(apply subsequence data %) (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 1))))\n~~~\n  "],"^>","~$gadjett.collections/split-by-predicate-positions","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",35,"^T",["^P",[["^1@","^1A","~$n","~$d"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",394,"^X","~$cljs.core/LazySeq","^M",394,"^Z",4,"^[",true,"^O",["^P",["^Q",["^P",[["^1@","^1A","~$n","~$d"]]]]],"^R","\n  Optimized version of `split-by-predicate` where we assume that the data is from a signal that we can sample.\n\n  Instead of checking each element, we check 1 over `n` elements.\n\n We return the positions where the data splits.\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.001))]\n    (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 10))\n~~~\n\n  The following assertion holds:\n\n~~~clojure\n  (= (split-by-predicate coll pred n)\n     (map #(apply subsequence data %) (split-by-predicate-positions coll pred n 1)))\n~~~\n\n  Here is an example:\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.01))]\n    (= (split-by-predicate data #(<= -0.01 % 0.01) 2)\n       (map #(apply subsequence data %) (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 1))))\n~~~\n  "],"~$mapify",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",315,"^L",7,"^M",315,"^N",13,"^O",["^P",["^Q",["^P",[["~$f","~$s"]]]]],"^R","\n  Takes a seq, and returns a map where the keys are the result of applying f to the elements in the seq.\n  The result of f should be unique for each element in the seq, otherwise you will loose some data.\n  If it is not unique, consider using [group-by](https://clojuredocs.org/clojure.core/group-by).\n\n~~~klipse\n  (mapify inc (range 5) )\n~~~\n  "],"^>","~$gadjett.collections/mapify","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",13,"^T",["^P",[["~$f","~$s"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",315,"^X","^12","^M",315,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$f","~$s"]]]]],"^R","\n  Takes a seq, and returns a map where the keys are the result of applying f to the elements in the seq.\n  The result of f should be unique for each element in the seq, otherwise you will loose some data.\n  If it is not unique, consider using [group-by](https://clojuredocs.org/clojure.core/group-by).\n\n~~~klipse\n  (mapify inc (range 5) )\n~~~\n  "],"~$submap?",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",427,"^L",7,"^M",427,"^N",14,"^O",["^P",["^Q",["^P",[["~$m1","~$m2"]]]]],"^R","Checks if `m1` is a submap of `m2`.\n  Map `m1` is a submap of `m2` if all key/value pairs in `m1` exist in `m2`.\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2})\n~~~\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2 :c nil})\n~~~\n  "],"^>","~$gadjett.collections/submap?","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",14,"^T",["^P",[["^1G","^1H"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",427,"^X","~$boolean","^M",427,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^1G","^1H"]]]]],"^R","Checks if `m1` is a submap of `m2`.\n  Map `m1` is a submap of `m2` if all key/value pairs in `m1` exist in `m2`.\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2})\n~~~\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2 :c nil})\n~~~\n  "],"~$positions",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",363,"^L",7,"^M",363,"^N",16,"^O",["^P",["^Q",["^P",[["~$coll-of-lengths","~$&",["^ ","~:keys",["~$max-val","~$first-val"],"~:or",["^ ","^1N","~$infinity","^1O",0]]]]]]],"^R","Receives a collection of lengths and returns a list of start and end positions. Options:\n  * `max-val`: (default `infinity`) - max value for `end`\n  * `first-val`: (default 0) - first value of `start`\n\n~~~klipse\n  (positions '(10 10 20) :first-val 100 :max-val 137)\n~~~\n\n  ","~:top-fn",["^ ","^W",true,"~:fixed-arity",1,"^Z",1,"^T",[["^P",["^1L",["^ ","^1M",["^1N","^1O"],"^1P",["^ ","^1N","^1Q","^1O",0]]]]],"^O",["^P",[["^1L","~$&",["^ ","^1M",["^1N","^1O"],"^1P",["^ ","^1N","^1Q","^1O",0]]]]],"^V",["^P",[null]]]],"^>","~$gadjett.collections/positions","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",16,"^1R",["^ ","^W",true,"^1S",1,"^Z",1,"^T",[["^P",["^1L",["^ ","^1M",["^1N","^1O"],"^1P",["^ ","^1N","^1Q","^1O",0]]]]],"^O",["^P",[["^1L","~$&",["^ ","^1M",["^1N","^1O"],"^1P",["^ ","^1N","^1Q","^1O",0]]]]],"^V",["^P",[null]]],"^T",[["^P",["^1L",["^ ","^1M",["^1N","^1O"],"^1P",["^ ","^1N","^1Q","^1O",0]]]]],"^U",null,"^1S",1,"^V",["^P",[null]],"^L",1,"^W",true,"~:methods",[["^ ","^1S",1,"^W",true,"~:tag","^1C"]],"^K",363,"^X","^Y","^M",363,"^Z",1,"^[",true,"^O",["^P",[["^1L","~$&",["^ ","^1M",["^1N","^1O"],"^1P",["^ ","^1N","^1Q","^1O",0]]]]],"^R","Receives a collection of lengths and returns a list of start and end positions. Options:\n  * `max-val`: (default `infinity`) - max value for `end`\n  * `first-val`: (default 0) - first value of `start`\n\n~~~klipse\n  (positions '(10 10 20) :first-val 100 :max-val 137)\n~~~\n\n  "],"~$filter-map",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",265,"^L",7,"^M",265,"^N",17,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Run a function on the values of a map and keep only the (key, value) pairs for which the function returns true\n  \n~~~klipse\n  (filter-map even? {:a 1 :b 2 :c 3})\n~~~\n  "],"^>","~$gadjett.collections/filter-map","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",17,"^T",["^P",[["~$f","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",265,"^X",["^<",[null,"^12","^Y"]],"^M",265,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Run a function on the values of a map and keep only the (key, value) pairs for which the function returns true\n  \n~~~klipse\n  (filter-map even? {:a 1 :b 2 :c 3})\n~~~\n  "],"~$vec->map",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",47,"^L",7,"^M",47,"^N",15,"^O",["^P",["^Q",["^P",[["~$vec"]]]]],"^R","Converts a 2d vec to a hash-map.\n\n~~~klipse\n   (vec->map [[:a 1] [:b 2]])\n~~~\n   "],"^>","~$gadjett.collections/vec->map","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",15,"^T",["^P",[["^1Z"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",47,"^X",["^<",[null,"^12","^Y"]],"^M",47,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["^1Z"]]]]],"^R","Converts a 2d vec to a hash-map.\n\n~~~klipse\n   (vec->map [[:a 1] [:b 2]])\n~~~\n   "],"~$assoc-cyclic",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",205,"^L",7,"^M",205,"^N",19,"^O",["^P",["^Q",["^P",[["^1@","~$k","~$v"],["^1@","~$k","~$v","~$n"]]]]],"^R","Assoc a key-value pair to a map popping out an element of the map.\n  If the key already exists, no element is popped out.\n  If `n` is supplied, no elmement is popped out if the map has less than `n` entries.\n\n~~~klipse\n  (-> {:a 1 :b 2 :c 3}\n      (assoc-cyclic :d 4)\n      (assoc-cyclic :e 5)\n      (assoc-cyclic :f 6)\n      (assoc-cyclic :g 7))\n~~~\n  ","^1R",["^ ","^W",false,"^1S",4,"^Z",4,"^T",[["^1@","~$k","~$v"],["^1@","~$k","~$v","~$n"]],"^O",["^P",[["^1@","~$k","~$v"],["^1@","~$k","~$v","~$n"]]],"^V",["^P",[null,null]]]],"^>","~$gadjett.collections/assoc-cyclic","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",19,"^1R",["^ ","^W",false,"^1S",4,"^Z",4,"^T",[["^1@","~$k","~$v"],["^1@","~$k","~$v","~$n"]],"^O",["^P",[["^1@","~$k","~$v"],["^1@","~$k","~$v","~$n"]]],"^V",["^P",[null,null]]],"^T",[["^1@","~$k","~$v"],["^1@","~$k","~$v","~$n"]],"^U",null,"^1S",4,"^V",["^P",[null,null]],"^L",1,"^W",false,"^1U",[["^ ","^1S",3,"^W",false,"^1V",["^<",[null,"^12","^Y"]]],["^ ","^1S",4,"^W",false,"^1V",["^<",[null,"^12","^Y"]]]],"^K",205,"^M",205,"^Z",4,"^[",true,"^O",["^P",[["^1@","~$k","~$v"],["^1@","~$k","~$v","~$n"]]],"^R","Assoc a key-value pair to a map popping out an element of the map.\n  If the key already exists, no element is popped out.\n  If `n` is supplied, no elmement is popped out if the map has less than `n` entries.\n\n~~~klipse\n  (-> {:a 1 :b 2 :c 3}\n      (assoc-cyclic :d 4)\n      (assoc-cyclic :e 5)\n      (assoc-cyclic :f 6)\n      (assoc-cyclic :g 7))\n~~~\n  "],"~$headers-and-rows->maps",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",857,"^L",7,"^M",857,"^N",29,"^O",["^P",["^Q",["^P",[["~$headers","~$rows"]]]]],"^R","Receives a tabular collection where the first elememt contains the headers\n  and the rest of the elements are the rows.\n  Returns a collection where each row is converted into a map whose keys are the headers.\n  In rows whose number of elements is lower than the number of headers, the missing headers won't appear in the corresponding map.\n  In rows whose number of elements is higher than the number of headers, the additional elements won't appear in the corresponding map.\n\n  See also: headers-and-maps->rows.\n\n  ~~~klipse\n  (headers-and-rows->maps  [\"name\" \"title\" \"total\"]\n                           [[\"David\" \"Architect\" 19]\n                            [\"Anna\" \"Dev\"]\n                            [\"Joe\" \"Analyst\" 88 321]])\n  ~~~\n  "],"^>","~$gadjett.collections/headers-and-rows->maps","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",29,"^T",["^P",[["^23","^24"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",857,"^X","^1C","^M",857,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^23","^24"]]]]],"^R","Receives a tabular collection where the first elememt contains the headers\n  and the rest of the elements are the rows.\n  Returns a collection where each row is converted into a map whose keys are the headers.\n  In rows whose number of elements is lower than the number of headers, the missing headers won't appear in the corresponding map.\n  In rows whose number of elements is higher than the number of headers, the additional elements won't appear in the corresponding map.\n\n  See also: headers-and-maps->rows.\n\n  ~~~klipse\n  (headers-and-rows->maps  [\"name\" \"title\" \"total\"]\n                           [[\"David\" \"Architect\" 19]\n                            [\"Anna\" \"Dev\"]\n                            [\"Joe\" \"Analyst\" 88 321]])\n  ~~~\n  "],"^1Q",["^ ","^>","~$gadjett.collections/infinity","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^K",7,"^L",1,"^M",7,"^N",14,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",7,"^L",6,"^M",7,"^N",14],"^1V","~$js/Number"],"~$subsequence",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",442,"^L",7,"^M",442,"^N",18,"^O",["^P",["^Q",["^P",[["^1@","~$start","~$end"]]]]],"^R","\n  Returns a lazy subsequence of `coll`, starting at `start, ending at `end` (not included).\n\n~~~klipse\n  (subsequence (range) 10 20)\n~~~\n  "],"^>","~$gadjett.collections/subsequence","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",18,"^T",["^P",[["^1@","^29","^2:"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",442,"^X","^1C","^M",442,"^Z",3,"^[",true,"^O",["^P",["^Q",["^P",[["^1@","^29","^2:"]]]]],"^R","\n  Returns a lazy subsequence of `coll`, starting at `start, ending at `end` (not included).\n\n~~~klipse\n  (subsequence (range) 10 20)\n~~~\n  "],"~$edn-zip",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",623,"^L",7,"^M",623,"^N",14,"^O",["^P",["^Q",["^P",[["~$root"]]]]],"^R","A zipper for `edn`.\n\n~~~klipse\n  (edn-zip {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"^>","~$gadjett.collections/edn-zip","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",14,"^T",["^P",[["^2="]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",623,"^X","^Y","^M",623,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["^2="]]]]],"^R","A zipper for `edn`.\n\n~~~klipse\n  (edn-zip {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"~$transform-keys",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",891,"^L",7,"^M",891,"^N",21,"^O",["^P",["^Q",["^P",[["~$transform","~$m"]]]]],"^R","Recursively transforms all map keys with some transform function.\n  ~~~klipse\n  (transform-keys name {:data {:qty 20}})\n  ~~~\n","~:added","1.1"],"^2A","1.1","^>","~$gadjett.collections/transform-keys","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",21,"^T",["^P",[["^2@","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",891,"^X","^Y","^M",891,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^2@","~$m"]]]]],"^R","Recursively transforms all map keys with some transform function.\n  ~~~klipse\n  (transform-keys name {:data {:qty 20}})\n  ~~~\n"],"~$fix-blank-lines",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",689,"^L",7,"^M",689,"^N",22,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes blank lines from the begining and from the end (not from the middle)\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (fix-blank-lines lines))\n~~~\n  "],"^>","~$gadjett.collections/fix-blank-lines","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",22,"^T",["^P",[["~$s"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",689,"^X","~$string","^M",689,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes blank lines from the begining and from the end (not from the middle)\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (fix-blank-lines lines))\n~~~\n  "],"~$map-to-object",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",305,"^L",7,"^M",305,"^N",20,"^O",["^P",["^Q",["^P",[["~$f","~$lst"]]]]],"^R","Returns a map whose keys are the elements of `lst` and values are mapped by `f`.\n\n~~~klipse\n  (map-to-object inc (range 5))\n~~~\n  "],"^>","~$gadjett.collections/map-to-object","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",20,"^T",["^P",[["~$f","^2G"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",305,"^X","^12","^M",305,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$f","^2G"]]]]],"^R","Returns a map whose keys are the elements of `lst` and values are mapped by `f`.\n\n~~~klipse\n  (map-to-object inc (range 5))\n~~~\n  "],"~$deep-merge",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",522,"^L",7,"^M",522,"^N",17,"^O",["^P",["^Q",["^P",[["~$&","~$maps"]]]]],"^R"," Deep merges maps.\n\n  ~~~klipse\n  (deep-merge {} {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}} {:a {:b 1}, :c {:e 4, :d 2000, :f {:g 9000}}})\n  ~~~\n  ","^1R",["^ ","^W",true,"^1S",0,"^Z",0,"^T",[["^P",["^2J"]]],"^O",["^P",[["~$&","^2J"]]],"^V",["^P",[null]]]],"^>","~$gadjett.collections/deep-merge","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",17,"^1R",["^ ","^W",true,"^1S",0,"^Z",0,"^T",[["^P",["^2J"]]],"^O",["^P",[["~$&","^2J"]]],"^V",["^P",[null]]],"^T",[["^P",["^2J"]]],"^U",null,"^1S",0,"^V",["^P",[null]],"^L",1,"^W",true,"^1U",[["^ ","^1S",0,"^W",true,"^1V","^Y"]],"^K",522,"^X","^Y","^M",522,"^Z",0,"^[",true,"^O",["^P",[["~$&","^2J"]]],"^R"," Deep merges maps.\n\n  ~~~klipse\n  (deep-merge {} {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}} {:a {:b 1}, :c {:e 4, :d 2000, :f {:g 9000}}})\n  ~~~\n  "],"~$mean",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",124,"^L",7,"^M",124,"^N",11,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Calculates the mean (a.k.a average) of a sequence of numbers.\n\n~~~klipse\n  (mean [1 2 10 -1 12.3])\n~~~\n  "],"^>","~$gadjett.collections/mean","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",11,"^T",["^P",[["~$x"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",124,"^X","~$number","^M",124,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Calculates the mean (a.k.a average) of a sequence of numbers.\n\n~~~klipse\n  (mean [1 2 10 -1 12.3])\n~~~\n  "],"~$loc-my-replace",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",648,"^L",8,"^M",648,"^N",22,"~:private",true,"^O",["^P",["^Q",["^P",[["~$smap","~$loc"]]]]]],"^2P",true,"^>","~$gadjett.collections/loc-my-replace","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",22,"^T",["^P",[["^2Q","^2R"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",648,"^X",["^<",[null,"^Y"]],"^M",648,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^2Q","^2R"]]]]]],"~$map-object-kv",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",100,"^L",7,"^M",100,"^N",20,"^O",["^P",["^Q",["^P",[["~$fk","~$fv","~$m"]]]]],"^R","Returns a map with the keys mapped by `fk` and the values mapped by `fv`.\n\n~~~klipse\n    (map-object-kv name inc {:a 1 :b 2 :c 3})\n~~~\n"],"^>","~$gadjett.collections/map-object-kv","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",20,"^T",["^P",[["^2U","^2V","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",100,"^X",["^<",[null,"^12","^Y"]],"^M",100,"^Z",3,"^[",true,"^O",["^P",["^Q",["^P",[["^2U","^2V","~$m"]]]]],"^R","Returns a map with the keys mapped by `fk` and the values mapped by `fv`.\n\n~~~klipse\n    (map-object-kv name inc {:a 1 :b 2 :c 3})\n~~~\n"],"~$compactize-map-recursive",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",249,"^L",7,"^M",249,"^N",31,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Remove from a map the entries whose values are `nil`.\n  If all the values of a nested map are `nil` the entrie is removed.\n~~~klipse\n\n(compactize-map-recursive {:x 1 :z {:a nil} :a {:b nil :c 2 :d {:e nil :f 2}}})\n~~~\n  "],"^>","~$gadjett.collections/compactize-map-recursive","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",31,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",249,"^X","^Y","^M",249,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Remove from a map the entries whose values are `nil`.\n  If all the values of a nested map are `nil` the entrie is removed.\n~~~klipse\n\n(compactize-map-recursive {:x 1 :z {:a nil} :a {:b nil :c 2 :d {:e nil :f 2}}})\n~~~\n  "],"~$flatten-keys",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",472,"^L",7,"^M",472,"^N",19,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","\nFlatten the keys of a nested map.\nThanks to [Jay Fields](http://blog.jayfields.com/2010/09/clojure-flatten-keys.html)\n\n~~~klipse\n(flatten-keys {:a {:b 1} :c {:d 2 :e 4 :f {:g 8}}})\n~~~\n"],"^>","~$gadjett.collections/flatten-keys","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",19,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",472,"^X",["^<",[null,"^12","^Y","~$cljs.core/IMap"]],"^M",472,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","\nFlatten the keys of a nested map.\nThanks to [Jay Fields](http://blog.jayfields.com/2010/09/clojure-flatten-keys.html)\n\n~~~klipse\n(flatten-keys {:a {:b 1} :c {:d 2 :e 4 :f {:g 8}}})\n~~~\n"],"~$scale",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",21,"^L",8,"^M",21,"^N",13,"^2P",true,"^O",["^P",["^Q",["^P",[["~$x","~$y"]]]]]],"^2P",true,"^>","~$gadjett.collections/scale","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",13,"^T",["^P",[["~$x","~$y"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",21,"^X",["^<",["^Y","^2N"]],"^M",21,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$x","~$y"]]]]]],"~$flatten-keys*",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",465,"^L",8,"^M",465,"^N",21,"^2P",true,"^O",["^P",["^Q",["^P",[["~$a","^19","~$m"]]]]]],"^2P",true,"^>","~$gadjett.collections/flatten-keys*","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",21,"^T",["^P",[["~$a","^19","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",465,"^X",["^<",[null,"^12","^Y","^30"]],"^M",465,"^Z",3,"^[",true,"^O",["^P",["^Q",["^P",[["~$a","^19","~$m"]]]]]],"~$almost=",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",26,"^L",7,"^M",26,"^N",14,"^O",["^P",["^Q",["^P",[["~$x","~$y"],["~$x","~$y","~$epsilon"]]]]],"^1R",["^ ","^W",false,"^1S",3,"^Z",3,"^T",[["~$x","~$y"],["~$x","~$y","^36"]],"^O",["^P",[["~$x","~$y"],["~$x","~$y","^36"]]],"^V",["^P",[null,null]]]],"^>","~$gadjett.collections/almost=","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",14,"^1R",["^ ","^W",false,"^1S",3,"^Z",3,"^T",[["~$x","~$y"],["~$x","~$y","^36"]],"^O",["^P",[["~$x","~$y"],["~$x","~$y","^36"]]],"^V",["^P",[null,null]]],"^T",[["~$x","~$y"],["~$x","~$y","^36"]],"^U",null,"^1S",3,"^V",["^P",[null,null]],"^L",1,"^W",false,"^1U",[["^ ","^1S",2,"^W",false,"^1V","^Y"],["^ ","^1S",3,"^W",false,"^1V","^1J"]],"^K",26,"^M",26,"^Z",3,"^[",true,"^O",["^P",[["~$x","~$y"],["~$x","~$y","^36"]]]],"~$compactize-map",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",239,"^L",7,"^M",239,"^N",21,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Removes entries with `nil` values.\n\n~~~klipse\n  (compactize-map {:a 1 :b nil :c 3})\n~~~\n  "],"^>","~$gadjett.collections/compactize-map","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",21,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",239,"^X",["^<",[null,"^12","^Y"]],"^M",239,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Removes entries with `nil` values.\n\n~~~klipse\n  (compactize-map {:a 1 :b nil :c 3})\n~~~\n  "],"~$partition-between",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",593,"^L",7,"^M",593,"^N",24,"^O",["^P",["^Q",["^P",[["^1A","^1@"]]]]],"^R","Splits a collection between two items according to predicate `pred` - which means split the sequence on breaking point.\n\n  See: [here](http://stackoverflow.com/questions/23207490/partition-a-seq-by-a-windowing-predicate-in-clojure)\n\n  For instance, split each time the series stop being ascending:\n\n~~~klipse\n(partition-between > [1 2 4 9 8 7 6 5 1 2 4 5 11])\n~~~\n"],"^>","~$gadjett.collections/partition-between","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",24,"^T",["^P",[["^1A","^1@"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",593,"^X","^1C","^M",593,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^1A","^1@"]]]]],"^R","Splits a collection between two items according to predicate `pred` - which means split the sequence on breaking point.\n\n  See: [here](http://stackoverflow.com/questions/23207490/partition-a-seq-by-a-windowing-predicate-in-clojure)\n\n  For instance, split each time the series stop being ascending:\n\n~~~klipse\n(partition-between > [1 2 4 9 8 7 6 5 1 2 4 5 11])\n~~~\n"],"~$take-from-map",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",494,"^L",7,"^M",494,"^N",20,"^O",["^P",["^Q",["^P",[["~$n","~$m"]]]]],"^R","Creates a map with n leaves which are nested values of m.\n  The following assertion holds:\n\n~~~clojure\n      (>= n (count (flatten-keys (take-from-map n m)))))))\n~~~\n\n~~~klipse\n  (take-from-map 3 {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"^>","~$gadjett.collections/take-from-map","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",20,"^T",["^P",[["~$n","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",494,"^X",["^<",[null,"^Y"]],"^M",494,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$n","~$m"]]]]],"^R","Creates a map with n leaves which are nested values of m.\n  The following assertion holds:\n\n~~~clojure\n      (>= n (count (flatten-keys (take-from-map n m)))))))\n~~~\n\n~~~klipse\n  (take-from-map 3 {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"~$map-nested-vals",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",758,"^L",7,"^M",758,"^N",22,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Map the values of a nested map.\n~~~klipse\n  (map-nested-vals first {:a [1 2 3]\n                          :b {:c [4 5 6]}})\n~~~\n  "],"^>","~$gadjett.collections/map-nested-vals","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",22,"^T",["^P",[["~$f","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",758,"^X",["^<",[null,"^Y"]],"^M",758,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Map the values of a nested map.\n~~~klipse\n  (map-nested-vals first {:a [1 2 3]\n                          :b {:c [4 5 6]}})\n~~~\n  "],"~$compact",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",722,"^L",11,"^M",722,"^N",18,"^O",["^P",["^Q",["^P",[["~$x","~$&",["^ ","^1M",["~$max-elements-in-coll","~$max-chars-in-str"],"^1P",["^ ","^3A",10,"^3B",20],"^1:","~$args"]]]]]],"^R","\n(clojurescript only)\n\nCompacts an expression by taking only the first `max-elements-in-coll` from collections and first `max-chars-in-str` from strings. Functions are displayed as \"lambda()\".\n\nIt works recursively. It is useful for logging and reporting.\n\nDefault settings:\n\n- `max-elements-in-coll` 10\n- `max-chars-in-str` 20\n\n~~~klipse\n(compact {:infinite-list (range)\n          :long-str \"a very very very very long string - too long to be true\"\n                                                      :long-map (zipmap (range 100) (range 100))\n                                                        :function #(+ 1 2)})\n~~~\n                  ","^1R",["^ ","^W",true,"^1S",1,"^Z",1,"^T",[["^P",["~$x",["^ ","^1M",["^3A","^3B"],"^1P",["^ ","^3A",10,"^3B",20],"^1:","^3C"]]]],"^O",["^P",[["~$x","~$&",["^ ","^1M",["^3A","^3B"],"^1P",["^ ","^3A",10,"^3B",20],"^1:","^3C"]]]],"^V",["^P",[null]]]],"^>","~$gadjett.collections/compact","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",18,"^1R",["^ ","^W",true,"^1S",1,"^Z",1,"^T",[["^P",["~$x",["^ ","^1M",["^3A","^3B"],"^1P",["^ ","^3A",10,"^3B",20],"^1:","^3C"]]]],"^O",["^P",[["~$x","~$&",["^ ","^1M",["^3A","^3B"],"^1P",["^ ","^3A",10,"^3B",20],"^1:","^3C"]]]],"^V",["^P",[null]]],"^T",[["^P",["~$x",["^ ","^1M",["^3A","^3B"],"^1P",["^ ","^3A",10,"^3B",20],"^1:","^3C"]]]],"^U",null,"^1S",1,"^V",["^P",[null]],"^L",5,"^W",true,"^1U",[["^ ","^1S",1,"^W",true,"^1V",["^<",[null,"^Y","~$cljs.core/Keyword","^1C","^2N","^2E","^1>"]]]],"^K",722,"^X","^Y","^M",722,"^Z",1,"^[",true,"^O",["^P",[["~$x","~$&",["^ ","^1M",["^3A","^3B"],"^1P",["^ ","^3A",10,"^3B",20],"^1:","^3C"]]]],"^R","\n(clojurescript only)\n\nCompacts an expression by taking only the first `max-elements-in-coll` from collections and first `max-chars-in-str` from strings. Functions are displayed as \"lambda()\".\n\nIt works recursively. It is useful for logging and reporting.\n\nDefault settings:\n\n- `max-elements-in-coll` 10\n- `max-chars-in-str` 20\n\n~~~klipse\n(compact {:infinite-list (range)\n          :long-str \"a very very very very long string - too long to be true\"\n                                                      :long-map (zipmap (range 100) (range 100))\n                                                        :function #(+ 1 2)})\n~~~\n                  "],"~$substr",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",788,"^L",7,"^M",788,"^N",13,"^O",["^P",["^Q",["^P",[["~$s","^29"],["~$s","^29","^2:"]]]]],"^R","Like clojure.core/subs but prevents some exceptions when the `start` or `end` are out of bound.\n~~~klipse\n  (subs \"\" -2)\n~~~\n\n  ","^1R",["^ ","^W",false,"^1S",3,"^Z",3,"^T",[["~$s","^29"],["~$s","^29","^2:"]],"^O",["^P",[["~$s","^29"],["~$s","^29","^2:"]]],"^V",["^P",[null,null]]]],"^>","~$gadjett.collections/substr","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",13,"^1R",["^ ","^W",false,"^1S",3,"^Z",3,"^T",[["~$s","^29"],["~$s","^29","^2:"]],"^O",["^P",[["~$s","^29"],["~$s","^29","^2:"]]],"^V",["^P",[null,null]]],"^T",[["~$s","^29"],["~$s","^29","^2:"]],"^U",null,"^1S",3,"^V",["^P",[null,null]],"^L",1,"^W",false,"^1U",[["^ ","^1S",2,"^W",false,"^1V","^2E"],["^ ","^1S",3,"^W",false,"^1V","^2E"]],"^K",788,"^M",788,"^Z",3,"^[",true,"^O",["^P",[["~$s","^29"],["~$s","^29","^2:"]]],"^R","Like clojure.core/subs but prevents some exceptions when the `start` or `end` are out of bound.\n~~~klipse\n  (subs \"\" -2)\n~~~\n\n  "],"~$map-with-index",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",328,"^L",7,"^M",328,"^N",21,"^O",["^P",["^Q",["^P",[["~$s","~$idx-key","~$val-key"]]]]],"^R","Maps a sequence to a sequence of maps with index and value\n\n~~~klipse\n      (map-with-index [10 20 30] :idx :val)\n~~~\n  "],"^>","~$gadjett.collections/map-with-index","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",21,"^T",["^P",[["~$s","^3I","^3J"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",328,"^X","^Y","^M",328,"^Z",3,"^[",true,"^O",["^P",["^Q",["^P",[["~$s","^3I","^3J"]]]]],"^R","Maps a sequence to a sequence of maps with index and value\n\n~~~klipse\n      (map-with-index [10 20 30] :idx :val)\n~~~\n  "],"~$map-object-with-key",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",90,"^L",7,"^M",90,"^N",26,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` must be a `2-ary` function that receives the key and the value as arguments.\n\n~~~klipse\n  (map-object-with-key list {:a 1 :b 2 :c 3})\n~~~\n  "],"^>","~$gadjett.collections/map-object-with-key","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",26,"^T",["^P",[["~$f","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",90,"^X",["^<",[null,"^12","^Y"]],"^M",90,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` must be a `2-ary` function that receives the key and the value as arguments.\n\n~~~klipse\n  (map-object-with-key list {:a 1 :b 2 :c 3})\n~~~\n  "],"~$deep-merge*",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",513,"^L",8,"^M",513,"^N",19,"^2P",true,"^O",["^P",["^Q",["^P",[["~$&","^2J"]]]]],"^1R",["^ ","^W",true,"^1S",0,"^Z",0,"^T",[["^P",["^2J"]]],"^O",["^P",[["~$&","^2J"]]],"^V",["^P",[null]]]],"^2P",true,"^>","~$gadjett.collections/deep-merge*","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",19,"^1R",["^ ","^W",true,"^1S",0,"^Z",0,"^T",[["^P",["^2J"]]],"^O",["^P",[["~$&","^2J"]]],"^V",["^P",[null]]],"^T",[["^P",["^2J"]]],"^U",null,"^1S",0,"^V",["^P",[null]],"^L",1,"^W",true,"^1U",[["^ ","^1S",0,"^W",true,"^1V",["^<",["^Y","^1>"]]]],"^K",513,"^X","^Y","^M",513,"^Z",0,"^[",true,"^O",["^P",[["~$&","^2J"]]]],"~$range-till-end",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",169,"^L",7,"^M",169,"^N",21,"^O",["^P",["^Q",["^P",[["~$&","^3C"]]]]],"^R","Like `range` but including the `end`.\n\n~~~klipse\n  (range-till-end 10)\n~~~\n\n~~~klipse\n(range-till-end 10 18)\n~~~\n\n~~~klipse\n(range-till-end 10 100 5)\n~~~\n\n  ","^1R",["^ ","^W",true,"^1S",0,"^Z",0,"^T",[["^P",["^3C"]]],"^O",["^P",[["~$&","^3C"]]],"^V",["^P",[null]]]],"^>","~$gadjett.collections/range-till-end","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",21,"^1R",["^ ","^W",true,"^1S",0,"^Z",0,"^T",[["^P",["^3C"]]],"^O",["^P",[["~$&","^3C"]]],"^V",["^P",[null]]],"^T",[["^P",["^3C"]]],"^U",null,"^1S",0,"^V",["^P",[null]],"^L",1,"^W",true,"^1U",[["^ ","^1S",0,"^W",true,"^1V","^1C"]],"^K",169,"^X","^Y","^M",169,"^Z",0,"^[",true,"^O",["^P",[["~$&","^3C"]]],"^R","Like `range` but including the `end`.\n\n~~~klipse\n  (range-till-end 10)\n~~~\n\n~~~klipse\n(range-till-end 10 18)\n~~~\n\n~~~klipse\n(range-till-end 10 100 5)\n~~~\n\n  "],"~$nearest-of-seq",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",292,"^L",7,"^M",292,"^N",21,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^R","Maps each element of `b` to its nearest element in `a`.\n  If `a` is empty, returns `b`.\n\n~~~klipse\n  (nearest-of-seq (range 5) [1.2 3.4 4])\n~~~\n  "],"^>","~$gadjett.collections/nearest-of-seq","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",21,"^T",["^P",[["~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",292,"^X",["^<",[null,"^1C"]],"^M",292,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^R","Maps each element of `b` to its nearest element in `a`.\n  If `a` is empty, returns `b`.\n\n~~~klipse\n  (nearest-of-seq (range 5) [1.2 3.4 4])\n~~~\n  "],"~$range-with-end",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",164,"^L",8,"^M",164,"^N",22,"^2P",true,"^O",["^P",["^Q",["^P",[["^2:"],["^29","^2:"],["^29","^2:","~$steps"]]]]],"^1R",["^ ","^W",false,"^1S",3,"^Z",3,"^T",[["^2:"],["^29","^2:"],["^29","^2:","^3U"]],"^O",["^P",[["^2:"],["^29","^2:"],["^29","^2:","^3U"]]],"^V",["^P",[null,null,null]]]],"^2P",true,"^>","~$gadjett.collections/range-with-end","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",22,"^1R",["^ ","^W",false,"^1S",3,"^Z",3,"^T",[["^2:"],["^29","^2:"],["^29","^2:","^3U"]],"^O",["^P",[["^2:"],["^29","^2:"],["^29","^2:","^3U"]]],"^V",["^P",[null,null,null]]],"^T",[["^2:"],["^29","^2:"],["^29","^2:","^3U"]],"^U",null,"^1S",3,"^V",["^P",[null,null,null]],"^L",1,"^W",false,"^1U",[["^ ","^1S",1,"^W",false,"^1V","~$cljs.core/IVector"],["^ ","^1S",2,"^W",false,"^1V","^3W"],["^ ","^1S",3,"^W",false,"^1V","^3W"]],"^K",164,"^M",164,"^Z",3,"^[",true,"^O",["^P",[["^2:"],["^29","^2:"],["^29","^2:","^3U"]]]],"~$branches-and-leaves",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",557,"^L",7,"^M",557,"^N",26,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Returns all branches and leaves off a nested map object.\n\n~~~klipse\n(branches-and-leaves {:a {:b 1 :c {:d 2}} :e 3})\n~~~\n  "],"^>","~$gadjett.collections/branches-and-leaves","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",26,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",557,"^X",["^<",[null,"^Y"]],"^M",557,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Returns all branches and leaves off a nested map object.\n\n~~~klipse\n(branches-and-leaves {:a {:b 1 :c {:d 2}} :e 3})\n~~~\n  "],"~$deep-merge-with",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",543,"^L",7,"^M",543,"^N",22,"^O",["^P",["^Q",["^P",[["~$g","~$&","^2J"]]]]],"^R","Like merge-with but deep.\n~~~klipse\n(deep-merge-with concat\n                 {:x {:b [1]\n                      :a [1]}}\n                 {:x {:a [3 4]}})\n~~~\n","^1R",["^ ","^W",true,"^1S",1,"^Z",1,"^T",[["^P",["~$g","^2J"]]],"^O",["^P",[["~$g","~$&","^2J"]]],"^V",["^P",[null]]]],"^>","~$gadjett.collections/deep-merge-with","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",22,"^1R",["^ ","^W",true,"^1S",1,"^Z",1,"^T",[["^P",["~$g","^2J"]]],"^O",["^P",[["~$g","~$&","^2J"]]],"^V",["^P",[null]]],"^T",[["^P",["~$g","^2J"]]],"^U",null,"^1S",1,"^V",["^P",[null]],"^L",1,"^W",true,"^1U",[["^ ","^1S",1,"^W",true,"^1V","^Y"]],"^K",543,"^X","^Y","^M",543,"^Z",1,"^[",true,"^O",["^P",[["~$g","~$&","^2J"]]],"^R","Like merge-with but deep.\n~~~klipse\n(deep-merge-with concat\n                 {:x {:b [1]\n                      :a [1]}}\n                 {:x {:a [3 4]}})\n~~~\n"],"~$remove-blank-lines",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",707,"^L",7,"^M",707,"^N",25,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes blank lines.\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-blank-lines lines))\n~~~\n  "],"^>","~$gadjett.collections/remove-blank-lines","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",25,"^T",["^P",[["~$s"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",707,"^X","^2E","^M",707,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes blank lines.\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-blank-lines lines))\n~~~\n  "],"~$select-vals",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",807,"^L",7,"^M",807,"^N",18,"^O",["^P",["^Q",["^P",[["~$map","~$keyseq"]]]]]],"^>","~$gadjett.collections/select-vals","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",18,"^T",["^P",[["^43","^44"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",807,"^X",["^<",["~$cljs.core/ValSeq","^1>"]],"^M",807,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^43","^44"]]]]]],"~$sequence-of-maps->map",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",146,"^L",7,"^M",146,"^N",28,"^O",["^P",["^Q",["^P",[["^1@","~$key-fn","~$val-fn"]]]]],"^R","Converts a sequence of maps into a map where:\n\n  - the keys are extracted from the maps using `key-fn`\n  - the vals extracted from the maps using `val-fn`  \n  \n  ~~~klipse\n  (sequence-of-maps->map [{:key :price :value 19}\n                          {:key :quantity :value 100}]\n                          :key :value)\n  ~~~\n  "],"^>","~$gadjett.collections/sequence-of-maps->map","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",28,"^T",["^P",[["^1@","^48","^49"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",146,"^X",["^<",[null,"^Y"]],"^M",146,"^Z",3,"^[",true,"^O",["^P",["^Q",["^P",[["^1@","^48","^49"]]]]],"^R","Converts a sequence of maps into a map where:\n\n  - the keys are extracted from the maps using `key-fn`\n  - the vals extracted from the maps using `val-fn`  \n  \n  ~~~klipse\n  (sequence-of-maps->map [{:key :price :value 19}\n                          {:key :quantity :value 100}]\n                          :key :value)\n  ~~~\n  "],"~$apply-with-map",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",816,"^L",7,"^M",816,"^N",21,"^O",["^P",["^Q",["^P",[["~$f","^3C"]]]]],"^R","Call a function - that expects spliced key values - with a map (ignoring key/values where value is nil).\n   Useful when you need to remove some keys according to some conditions."],"^>","~$gadjett.collections/apply-with-map","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",21,"^T",["^P",[["~$f","^3C"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",816,"^X","^Y","^M",816,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$f","^3C"]]]]],"^R","Call a function - that expects spliced key values - with a map (ignoring key/values where value is nil).\n   Useful when you need to remove some keys according to some conditions."],"~$filter-branches",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",571,"^L",7,"^M",571,"^N",22,"^O",["^P",["^Q",["^P",[["~$m","~$p"]]]]],"^R","Filters branches of a (nested) map `m` according to a predicate `m`.\n\n~~~klipse\n(filter-branches {:x {:id 19 :b 1 :c {:id 2}} :e 3} :id)\n~~~\n  "],"^>","~$gadjett.collections/filter-branches","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",22,"^T",["^P",[["~$m","~$p"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",571,"^X","^1C","^M",571,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$m","~$p"]]]]],"^R","Filters branches of a (nested) map `m` according to a predicate `m`.\n\n~~~klipse\n(filter-branches {:x {:id 19 :b 1 :c {:id 2}} :e 3} :id)\n~~~\n  "],"~$select-keys-in-order",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",802,"^L",7,"^M",802,"^N",27,"^O",["^P",["^Q",["^P",[["~$m","^44"]]]]],"^R","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"],"^>","~$gadjett.collections/select-keys-in-order","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",27,"^T",["^P",[["~$m","^44"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",802,"^X","^1C","^M",802,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$m","^44"]]]]],"^R","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"],"~$comment?",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",670,"^L",8,"^M",670,"^N",16,"^2P",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]]],"^2P",true,"^>","~$gadjett.collections/comment?","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",16,"^T",["^P",[["~$s"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",670,"^X",["^<",["^12","^3W","^Y","~$cljs.core/MetaFn","^1>"]],"^M",670,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]]],"~$out-of-bound?",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",583,"^L",7,"^M",583,"^N",20,"^O",["^P",["^Q",["^P",[["~$v","~$idx"]]]]],"^R","Checks if index `idx` is in range of vector `v`. More efficient than `(get v idx)`\n\n~~~klipse\n    (map #(out-of-bound? [1 2 3] %) [-1 0 1 2 3 4])\n~~~\n  "],"^>","~$gadjett.collections/out-of-bound?","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",20,"^T",["^P",[["~$v","^4E"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",583,"^X","^1J","^M",583,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$v","^4E"]]]]],"^R","Checks if index `idx` is in range of vector `v`. More efficient than `(get v idx)`\n\n~~~klipse\n    (map #(out-of-bound? [1 2 3] %) [-1 0 1 2 3 4])\n~~~\n  "],"~$map-2d-vec",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",57,"^L",7,"^M",57,"^N",17,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-2d-vec inc [[:a 1] [:b 2]])\n~~~\n"],"^>","~$gadjett.collections/map-2d-vec","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",17,"^T",["^P",[["~$f","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",57,"^X","^1C","^M",57,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-2d-vec inc [[:a 1] [:b 2]])\n~~~\n"],"~$headers-and-maps->rows",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",876,"^L",7,"^M",876,"^N",29,"^O",["^P",["^Q",["^P",[["^23","^2J"]]]]],"^R","Receives a sequence of headers and a sequence of maps whose keys are presumably from the headers.\n  Returns a sequence of rows where elements are ordered as in the headers sequence.\n\n  See also: headers-and-rows->maps.\n  ~~~klipse\n    (headers-and-rows->maps [\"name\" \"title\" \"total\"]\n                          [[\"Joe\" \"Dev\" 88]\n                           [\"Kelly\" \"Architect\"]\n                           [\"Anna\" \"Analyst\" 1234 9999]])\n  ~~~\n  "],"^>","~$gadjett.collections/headers-and-maps->rows","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",29,"^T",["^P",[["^23","^2J"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",876,"^X","^1C","^M",876,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^23","^2J"]]]]],"^R","Receives a sequence of headers and a sequence of maps whose keys are presumably from the headers.\n  Returns a sequence of rows where elements are ordered as in the headers sequence.\n\n  See also: headers-and-rows->maps.\n  ~~~klipse\n    (headers-and-rows->maps [\"name\" \"title\" \"total\"]\n                          [[\"Joe\" \"Dev\" 88]\n                           [\"Kelly\" \"Architect\"]\n                           [\"Anna\" \"Analyst\" 1234 9999]])\n  ~~~\n  "],"~$split-by-predicate",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",378,"^L",7,"^M",378,"^N",25,"^O",["^P",["^Q",["^P",[["^1@","^1A","~$n"]]]]],"^R","Splits a collection to items where the separator is a repetition of at least n elements that satisfy `pred`.\n\n  Inspired by: [this question](http://stackoverflow.com/a/23555616/813665).\n\n~~~klipse\n  (split-by-predicate (shuffle (range 30)) even? 2)\n~~~\n  "],"^>","~$gadjett.collections/split-by-predicate","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",25,"^T",["^P",[["^1@","^1A","~$n"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",378,"^X","^1C","^M",378,"^Z",3,"^[",true,"^O",["^P",["^Q",["^P",[["^1@","^1A","~$n"]]]]],"^R","Splits a collection to items where the separator is a repetition of at least n elements that satisfy `pred`.\n\n  Inspired by: [this question](http://stackoverflow.com/a/23555616/813665).\n\n~~~klipse\n  (split-by-predicate (shuffle (range 30)) even? 2)\n~~~\n  "],"^=",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",10,"^L",7,"^M",10,"^N",10,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Absolute value of a number\n\n~~~klipse\n  (map abs (range -5 5))\n~~~\n\n"],"^>","~$gadjett.collections/abs","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",10,"^T",["^P",[["~$x"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",10,"^X","^Y","^M",10,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Absolute value of a number\n\n~~~klipse\n  (map abs (range -5 5))\n~~~\n\n"],"~$deep-merge-with*",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",534,"^L",8,"^M",534,"^N",24,"^2P",true,"^O",["^P",["^Q",["^P",[["~$g","~$&","^2J"]]]]],"^1R",["^ ","^W",true,"^1S",1,"^Z",1,"^T",[["^P",["~$g","^2J"]]],"^O",["^P",[["~$g","~$&","^2J"]]],"^V",["^P",[null]]]],"^2P",true,"^>","~$gadjett.collections/deep-merge-with*","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",24,"^1R",["^ ","^W",true,"^1S",1,"^Z",1,"^T",[["^P",["~$g","^2J"]]],"^O",["^P",[["~$g","~$&","^2J"]]],"^V",["^P",[null]]],"^T",[["^P",["~$g","^2J"]]],"^U",null,"^1S",1,"^V",["^P",[null]],"^L",1,"^W",true,"^1U",[["^ ","^1S",1,"^W",true,"^1V","^Y"]],"^K",534,"^X","^Y","^M",534,"^Z",1,"^[",true,"^O",["^P",[["~$g","~$&","^2J"]]]],"~$join-them",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",771,"^L",7,"^M",771,"^N",16,"^O",["^P",["^Q",["^P",[["~$fns","~$colls"]]]]],"^R","Join a sequence of collections `colls` according to function equality.\n   `fns` - a sequence of functions\n   `colls` - a sequence of collections\n~~~klipse\n(let [a [{:id 1 :price 19} {:id 2 :price 3}]\n        b [{:guid 1 :quantity 13}]]\n     (join-them [:id :guid] [a b]))\n~~~\n"],"^>","~$gadjett.collections/join-them","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",16,"^T",["^P",[["^4Q","^4R"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",771,"^X",["^<",["^46","^1>"]],"^M",771,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^4Q","^4R"]]]]],"^R","Join a sequence of collections `colls` according to function equality.\n   `fns` - a sequence of functions\n   `colls` - a sequence of collections\n~~~klipse\n(let [a [{:id 1 :price 19} {:id 2 :price 3}]\n        b [{:guid 1 :quantity 13}]]\n     (join-them [:id :guid] [a b]))\n~~~\n"],"~$append-cyclic",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",189,"^L",7,"^M",189,"^N",20,"^O",["^P",["^Q",["^P",[["^2G","~$a"]]]]],"^R","Appends an element to a list popping out the first element.\n\n~~~klipse\n  (-> (repeat 3 nil)\n      (append-cyclic 1)\n      (append-cyclic 2)\n      (append-cyclic 3)\n      (append-cyclic 4))\n~~~\n  "],"^>","~$gadjett.collections/append-cyclic","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",20,"^T",["^P",[["^2G","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",189,"^X",["^<",[null,"^1C"]],"^M",189,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^2G","~$a"]]]]],"^R","Appends an element to a list popping out the first element.\n\n~~~klipse\n  (-> (repeat 3 nil)\n      (append-cyclic 1)\n      (append-cyclic 2)\n      (append-cyclic 3)\n      (append-cyclic 4))\n~~~\n  "],"~$select-vals-in-order",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",810,"^L",7,"^M",810,"^N",27,"^O",["^P",["^Q",["^P",[["^43","^19"]]]]],"^R","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"],"^>","~$gadjett.collections/select-vals-in-order","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",27,"^T",["^P",[["^43","^19"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",810,"^X",["^<",[null,"^Y"]],"^M",810,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^43","^19"]]]]],"^R","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"],"~$collify",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",609,"^L",7,"^M",609,"^N",14,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Ensure `s` is a collection: if `s` is a collection returns it; otherwise returns (s)\n\n~~~klipse\n(collify 1)\n~~~\n\n~~~klipse\n(collify [1 2 3])\n~~~\n  "],"^>","~$gadjett.collections/collify","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",14,"^T",["^P",[["~$s"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",609,"^X",["^<",[null,"~$cljs.core/List"]],"^M",609,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Ensure `s` is a collection: if `s` is a collection returns it; otherwise returns (s)\n\n~~~klipse\n(collify 1)\n~~~\n\n~~~klipse\n(collify [1 2 3])\n~~~\n  "],"~$map-2d-vec-kv",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",68,"^L",7,"^M",68,"^N",20,"^O",["^P",["^Q",["^P",[["^2U","^2V","~$m"]]]]],"^R","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`fk` is a `1-ary` function that receives the key.\n`fv` is a `1-ary` function that receives the value.\n\n~~~klipse\n    (map-2d-vec-kv name inc [[:a 1] [:b 2]])\n~~~\n"],"^>","~$gadjett.collections/map-2d-vec-kv","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",20,"^T",["^P",[["^2U","^2V","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",68,"^X","^1C","^M",68,"^Z",3,"^[",true,"^O",["^P",["^Q",["^P",[["^2U","^2V","~$m"]]]]],"^R","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`fk` is a `1-ary` function that receives the key.\n`fv` is a `1-ary` function that receives the value.\n\n~~~klipse\n    (map-2d-vec-kv name inc [[:a 1] [:b 2]])\n~~~\n"],"~$max-and-min",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",227,"^L",7,"^M",227,"^N",18,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Returns a couple of the `max` and the `min` of a sequence.\n\n~~~klipse\n  (max-and-min (range 5))\n~~~\n  "],"^>","~$gadjett.collections/max-and-min","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",18,"^T",["^P",[["~$x"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",227,"^X",["^<",["^3W","^Y"]],"^M",227,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Returns a couple of the `max` and the `min` of a sequence.\n\n~~~klipse\n  (max-and-min (range 5))\n~~~\n  "],"~$order-by",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",825,"^L",7,"^M",825,"^N",15,"^O",["^P",["^Q",["^P",[["~$keyfn-direction-pairs","^1@"]]]]],"^R","\n  Receives [keyfn1 direction1 keyfn2 direction1 ...] coll\n  Returns a sorted sequence of the items in coll, where the sort\n  order is determined by comparing (keyfn1 item) with direction\n  direction1, then by comparing (keyfn2 item) with direction\n  direction2 ...\n\n  ~~~klipse\n  (order-by [first :desc second :asc] [[9 7] [9 4] [2 5] [9 2]])\n  ~~~\n  "],"^>","~$gadjett.collections/order-by","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",15,"^T",["^P",[["^54","^1@"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",825,"^X",["^<",["^12","~$cljs.core/IList","^4C","^1>"]],"^M",825,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^54","^1@"]]]]],"^R","\n  Receives [keyfn1 direction1 keyfn2 direction1 ...] coll\n  Returns a sorted sequence of the items in coll, where the sort\n  order is determined by comparing (keyfn1 item) with direction\n  direction1, then by comparing (keyfn2 item) with direction\n  direction2 ...\n\n  ~~~klipse\n  (order-by [first :desc second :asc] [[9 7] [9 4] [2 5] [9 2]])\n  ~~~\n  "],"~$index-of",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",454,"^L",7,"^M",454,"^N",15,"^O",["^P",["^Q",["^P",[["~$s","~$element"]]]]],"^R","Returns the index of an element in a sequence or `-1` if not present.\n\n  ~~~klipse\n  (index-of (range 100) 18)\n  ~~~\n  "],"^>","~$gadjett.collections/index-of","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",15,"^T",["^P",[["~$s","^58"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",454,"^X",["^<",["^Y","^2N"]],"^M",454,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$s","^58"]]]]],"^R","Returns the index of an element in a sequence or `-1` if not present.\n\n  ~~~klipse\n  (index-of (range 100) 18)\n  ~~~\n  "],"~$nearest-of-ss",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",280,"^L",7,"^M",280,"^N",20,"^O",["^P",["^Q",["^P",[["~$ss","~$x"]]]]],"^R","Returns the nearest number to `x` of a sorted set\n\n~~~klipse\n  (nearest-of-ss (apply sorted-set (range 5)) 1.2)\n~~~\n  "],"^>","~$gadjett.collections/nearest-of-ss","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",20,"^T",["^P",[["^5;","~$x"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",280,"^X","^Y","^M",280,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^5;","~$x"]]]]],"^R","Returns the nearest number to `x` of a sorted set\n\n~~~klipse\n  (nearest-of-ss (apply sorted-set (range 5)) 1.2)\n~~~\n  "],"~$map-reverse-hierarchy",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",110,"^L",7,"^M",110,"^N",28,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Turns a hash map inside out.\n  See:  [here](http://stackoverflow.com/a/23653784/813665)\n\n~~~klipse\n  (map-reverse-hierarchy {:monday {:banana 2 :apple 3} \n                          :tuesday {:banana 5 :orange 2}})\n~~~\n"],"^>","~$gadjett.collections/map-reverse-hierarchy","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",28,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",110,"^X",["^<",["^Y","^30"]],"^M",110,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Turns a hash map inside out.\n  See:  [here](http://stackoverflow.com/a/23653784/813665)\n\n~~~klipse\n  (map-reverse-hierarchy {:monday {:banana 2 :apple 3} \n                          :tuesday {:banana 5 :orange 2}})\n~~~\n"],"~$remove-ending-comments",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",673,"^L",7,"^M",673,"^N",29,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes comment lines from the end.\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"aa\", \"  \", \"bb\" \"; this comment should not appear\"])]\n  (remove-ending-comments lines))\n~~~\n  "],"^>","~$gadjett.collections/remove-ending-comments","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",29,"^T",["^P",[["~$s"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",673,"^X","^2E","^M",673,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes comment lines from the end.\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"aa\", \"  \", \"bb\" \"; this comment should not appear\"])]\n  (remove-ending-comments lines))\n~~~\n  "],"~$map-object",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",80,"^L",7,"^M",80,"^N",17,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-object inc {:a 1 :b 2 :c 3})\n~~~\n  "],"^>","~$gadjett.collections/map-object","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",17,"^T",["^P",[["~$f","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",80,"^X",["^<",[null,"^12","^Y"]],"^M",80,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-object inc {:a 1 :b 2 :c 3})\n~~~\n  "],"~$=set",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",33,"^L",8,"^M",33,"^N",12,"^2P",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]]],"^2P",true,"^>","~$gadjett.collections/=set","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",12,"^T",["^P",[["~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",33,"^X","^1J","^M",33,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]]],"~$my-replace",["^ ","^H",null,"^I",["^ ","^J","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/gadjett/collections.cljc","^K",655,"^L",7,"^M",655,"^N",17,"^O",["^P",["^Q",["^P",[["^2Q","~$form"]]]]],"^R","Recursively transforms `form` by replacing keys in `smap` with their\n  values, spliced. The values in `smap` must be sequences. Like clojure.walk/prewalk-replace but supports list in values.\n\n~~~klipse\n(my-replace '{go (go gadjett)} '(go (<! (timeout 100)) (go (<! timeout 0))))\n~~~\n  "],"^>","~$gadjett.collections/my-replace","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",17,"^T",["^P",[["^2Q","^5F"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",655,"^X","^Y","^M",655,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^2Q","^5F"]]]]],"^R","Recursively transforms `form` by replacing keys in `smap` with their\n  values, spliced. The values in `smap` must be sequences. Like clojure.walk/prewalk-replace but supports list in values.\n\n~~~klipse\n(my-replace '{go (go gadjett)} '(go (<! (timeout 100)) (go (<! timeout 0))))\n~~~\n  "]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^<",["~:max-elements-in-coll","~:desc","~:else","~:max-chars-in-str","~:asc","~:first-val","~:branches","~:leaves","~:max-val"]],"~:order",["^5T","^5Q","^5R","^5S","^5L","^5O","^5N","^5M","^5P"]],"^R",null,"~:as-aliases",["^ "]]