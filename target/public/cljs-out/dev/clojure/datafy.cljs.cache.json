["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$clojure.datafy","~:imports",null,"~:requires",["^ ","~$p","~$clojure.core.protocols","^9","^9"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$datafy",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/viebel/prj/klipse-clj/target/public/cljs-out/dev/clojure/datafy.cljs","~:line",14,"~:column",7,"~:end-line",14,"~:end-column",13,"~:arglists",["~#list",["~$quote",["^F",[["~$x"]]]]],"~:doc","Attempts to return x as data.\n  datafy will return the value of clojure.protocols/datafy. If\n  the value has been transformed and the result supports\n  metadata, :clojure.datafy/obj will be set on the metadata to the\n  original value of x."],"^5","~$clojure.datafy/datafy","^@","target/public/cljs-out/dev/clojure/datafy.cljs","^D",13,"~:method-params",["^F",[["~$x"]]],"~:protocol-impl",null,"~:arglists-meta",["^F",[null,null]],"^B",1,"~:variadic?",false,"^A",14,"~:ret-tag",["^4",["~$clj","~$any","~$cljs.core/MetaFn","~$clj-nil"]],"^C",14,"~:max-fixed-arity",1,"~:fn-var",true,"^E",["^F",["^G",["^F",[["~$x"]]]]],"^H","Attempts to return x as data.\n  datafy will return the value of clojure.protocols/datafy. If\n  the value has been transformed and the result supports\n  metadata, :clojure.datafy/obj will be set on the metadata to the\n  original value of x."],"~$nav",["^ ","^>",null,"^?",["^ ","^@","/Users/viebel/prj/klipse-clj/target/public/cljs-out/dev/clojure/datafy.cljs","^A",31,"^B",7,"^C",31,"^D",10,"^E",["^F",["^G",["^F",[["~$coll","~$k","~$v"]]]]],"^H","Returns (possibly transformed) v in the context of coll and k (a\n  key/index or nil). Callers should attempt to provide the key/index\n  context k for Indexed/Associative/ILookup colls if possible, but not\n  to fabricate one e.g. for sequences (pass nil). nav will return the\n  value of clojure.core.protocols/nav."],"^5","~$clojure.datafy/nav","^@","target/public/cljs-out/dev/clojure/datafy.cljs","^D",10,"^J",["^F",[["^V","~$k","~$v"]]],"^K",null,"^L",["^F",[null,null]],"^B",1,"^M",false,"^A",31,"^N","^P","^C",31,"^S",3,"^T",true,"^E",["^F",["^G",["^F",[["^V","~$k","~$v"]]]]],"^H","Returns (possibly transformed) v in the context of coll and k (a\n  key/index or nil). Callers should attempt to provide the key/index\n  context k for Indexed/Associative/ILookup colls if possible, but not\n  to fabricate one e.g. for sequences (pass nil). nav will return the\n  value of clojure.core.protocols/nav."],"~$datify-ref",["^ ","^>",null,"^?",["^ ","^@","/Users/viebel/prj/klipse-clj/target/public/cljs-out/dev/clojure/datafy.cljs","^A",40,"^B",8,"^C",40,"^D",18,"~:private",true,"^E",["^F",["^G",["^F",[["~$r"]]]]]],"^Y",true,"^5","~$clojure.datafy/datify-ref","^@","target/public/cljs-out/dev/clojure/datafy.cljs","^D",18,"^J",["^F",[["~$r"]]],"^K",null,"^L",["^F",[null,null]],"^B",1,"^M",false,"^A",40,"^N",["^4",["^O","^Q","^R"]],"^C",40,"^S",1,"^T",true,"^E",["^F",["^G",["^F",[["~$r"]]]]]]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:clojure.datafy/obj"]],"~:order",["^13"]],"^H","Functions to turn objects into data. Alpha, subject to change"]