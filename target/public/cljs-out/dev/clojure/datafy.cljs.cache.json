["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ ","~$prototype",["^ ","~$clojure$core$protocols$Datafiable$",["^ "],"~$clojure$core$protocols$Datafiable$datafy$arity$1",["^ "]]]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$clojure.datafy","~:imports",null,"~:requires",["^ ","~$p","~$clojure.core.protocols","^>","^>"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$datafy",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/clojure/datafy.cljs","~:line",14,"~:column",7,"~:end-line",14,"~:end-column",13,"~:arglists",["~#list",["~$quote",["^K",[["~$x"]]]]],"~:doc","Attempts to return x as data.\n  datafy will return the value of clojure.protocols/datafy. If\n  the value has been transformed and the result supports\n  metadata, :clojure.datafy/obj will be set on the metadata to the\n  original value of x."],"^:","~$clojure.datafy/datafy","^E","target/public/cljs-out/dev/clojure/datafy.cljs","^I",13,"~:method-params",["^K",[["~$x"]]],"~:protocol-impl",null,"~:arglists-meta",["^K",[null,null]],"^G",1,"~:variadic?",false,"^F",14,"~:ret-tag",["^9",["~$clj","~$any","~$cljs.core/MetaFn","~$clj-nil"]],"^H",14,"~:max-fixed-arity",1,"~:fn-var",true,"^J",["^K",["^L",["^K",[["~$x"]]]]],"^M","Attempts to return x as data.\n  datafy will return the value of clojure.protocols/datafy. If\n  the value has been transformed and the result supports\n  metadata, :clojure.datafy/obj will be set on the metadata to the\n  original value of x."],"~$nav",["^ ","^C",null,"^D",["^ ","^E","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/clojure/datafy.cljs","^F",31,"^G",7,"^H",31,"^I",10,"^J",["^K",["^L",["^K",[["~$coll","~$k","~$v"]]]]],"^M","Returns (possibly transformed) v in the context of coll and k (a\n  key/index or nil). Callers should attempt to provide the key/index\n  context k for Indexed/Associative/ILookup colls if possible, but not\n  to fabricate one e.g. for sequences (pass nil). nav will return the\n  value of clojure.core.protocols/nav."],"^:","~$clojure.datafy/nav","^E","target/public/cljs-out/dev/clojure/datafy.cljs","^I",10,"^O",["^K",[["^[","~$k","~$v"]]],"^P",null,"^Q",["^K",[null,null]],"^G",1,"^R",false,"^F",31,"^S","^U","^H",31,"^X",3,"^Y",true,"^J",["^K",["^L",["^K",[["^[","~$k","~$v"]]]]],"^M","Returns (possibly transformed) v in the context of coll and k (a\n  key/index or nil). Callers should attempt to provide the key/index\n  context k for Indexed/Associative/ILookup colls if possible, but not\n  to fabricate one e.g. for sequences (pass nil). nav will return the\n  value of clojure.core.protocols/nav."],"~$datify-ref",["^ ","^C",null,"^D",["^ ","^E","/Users/penryu/code/github/klipse-clj/target/public/cljs-out/dev/clojure/datafy.cljs","^F",40,"^G",8,"^H",40,"^I",18,"~:private",true,"^J",["^K",["^L",["^K",[["~$r"]]]]]],"^12",true,"^:","~$clojure.datafy/datify-ref","^E","target/public/cljs-out/dev/clojure/datafy.cljs","^I",18,"^O",["^K",[["~$r"]]],"^P",null,"^Q",["^K",[null,null]],"^G",1,"^R",false,"^F",40,"^S",["^9",["^T","^V","^W"]],"^H",40,"^X",1,"^Y",true,"^J",["^K",["^L",["^K",[["~$r"]]]]]]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^9",["~:clojure.datafy/obj"]],"~:order",["^18"]],"^M","Functions to turn objects into data. Alpha, subject to change","~:as-aliases",["^ "]]